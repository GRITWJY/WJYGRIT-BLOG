---
title: 手写mvvm框架-1-数据驱动+渲染  
date: 2022-07-04 21:58:34  
permalink: /pages/mymvvm-01/  
categories:
    - 前端
    - 源码系列
    - vue源码解析
tags:
    - vue
    - 源码
author:  
    name: WJYGRIT   
    link: https://github.com/GRITWJY  
---

# 手写mvvm框架-1-数据驱动+渲染

vue源码学习停了半个月左右, 一方面是期末的几个课设, 另一方面也是因为百度的技术中心中有个作业是关于MVVM框架的,然后这几天
就在思考这个mvvm框架该怎么写了, 好在从去年开始就陆陆续续在B站上找些vue的原理课在听, 所以基本上算是有点基础.


先来看下这个作业的要求
- 实现数据劫持 (响应式)
- 实现发布订阅模式 `(触发更新: watcher)`
- 实现数据单向绑定 `(v-bind)`
- 实现数据双向绑定 `(v-model)`

然后我这边计划的步骤如下
- 1. 数据驱动(编译)
- 2. 渲染    
- 3. 响应式(数据劫持)
- 4. `watcher与dep`(发布订阅模式)
- 5. 单向绑定
- 6. 双向绑定
    

每一个板块都会有配套的源码解析, 即先阅读vue源码了解原理后, 再写一个简易版的.
说实话, 这样学vue源码可能会更高效点, 就拿编译这部分来说, 我当时学的时候是被
那么多个函数的调用给劝退了, 不仅仅是函数之间调用, 还有返回值, 指不定现在用的函数就是
前面哪个层级返回的, 当时是真的没弄懂, 也没有心思去深究. 

但现在不一样了哈, 要自己实现一个, 只好一点一点去研究了呗, 这篇文章是简易版, 源码的可看这篇文章


[[toc]]

## v1 - 起点: 实现替换掉`{{}}`里的内容

最开始我们不去讨论vue中经典的响应式原理怎么实现, 也不去担心diff算法多么多么复杂, 就从vue最简单的示例开始仿照[我自己认为的哈]
```
<div id="app">
  {{ message }}
</div>

var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```
即 如何让页面中显示的是 `hello vue` 而不是 message, 这里我们抛开 vue 源码中的 AST 和 字符串处理的形式, 因为它们那个应该是
优化之后的, (不然不会那么多复杂情况, 咱们这简单一点). 这里我就用之前在学习的时候学到的一个方法, 直接获取节点, 然后改变里面的`nodeValue值`.

哎, 想到这里是不是就感觉挺简单的了, 我只要按照如下步骤
- 1. 获取挂载节点和数据, 如`#app`

- 2. 递归遍历结点, 找到其中文本结点, 元素节点继续递归
    
- 3. 获取文本结点中的 `{{}}`的内容, 用 `data` 里响应的数据替换
    
### 1.1. 获取挂载结点和数据
```html
    <div id="app">
      <div>
        <div>
          <div>{{ name }} - {{ message }}</div>
        </div>
      </div>
      <p>{{ name }}</p>
      <p>{{ message }}</p>
    </div>
    <script>
        let tmpNode = document.querySelector("#app");
        let data = {
            name: "wjygrit",
            message: "实现 数据的填充",
        };
    </script>
```


### 1.2. 递归遍历结点, 找到其中的文本节点, 元素节点继续递归

```javascript
      function compiler(template, data) {
        // 判断子元素是否是文本节点
        // debugger;
        let childNodes = template.childNodes;
        for (let i = 0; i < childNodes.length; i++) {
          /**判断什么呢?这里先打个断点看看 #app下所有的内容**/
          /* 可以看到,我们现在的案例中, {{}} 是在text标签下的,那么我们就可以递归去找
              text标签,然后拿到 {{}} 这个后,再来进行处理
              * text
                  data: "{{ message }}"
                  length: 13
                  nodeName: "#text"
                  nodeType: 3
                  nodeValue: "{{ message }}"
              * */

          let type = childNodes[i].nodeType;
          // debugger;
          if (type === 3) {
            // 文本
            let txt = childNodes[i].nodeValue; // 获取到内容
            console.log(txt);
            // todo: 替换值
          } else {
            /** 什么时候递归下一个呢?**/
            // 在nodeType 里, 为1的话表示元素, 即当 nodeType = 1 时,我们递归
            compiler(childNodes[i], data);
          }
        }
      }
```



### 1.3. 替换data中相应的值
```javascript
    let reg = /\{\{(.+?)\}\}/g; // 获取{{}}里的内容的正则
    // {{name}}
    txt = txt.replace(reg, function (_, g) {
        console.log(g); // name 
        let key = g.trim();// key = name
        let value = data[key]; // data[name]
        return value;
    });
    childNodes[i].nodeValue = txt; // 替换掉原来的值
```
到这里, 调用 `compiler(tmpNode, data)`, 页面上的数据就相应该过来了.

但第一个版本还没完, 还有最后一步.

### 1.4. 保留模板

这一步也是在学习的时候学到的, 即 经过`vue`之后页面上的元素与我们自己在`vue`文件中写的不是同一个DOM.

然后原因是: 如果传入tmpNode(即包含 `{{}}` 的模板), 在经过compiler后, tmpNode 里的 `{{}}` 就全部被替换掉了, 
那如果之后数据改变了,需要更新结点, 从哪去找相应的 `{{}}` 呢?

所以, 我们稍微改一下就可以实现这目的了
```javascript
    let generateNode = tmpNode.cloneNode(true); // DOM元素可以通过此克隆
    compiler(generateNode, data);
    // 放到页面中
    app.parentNode.replaceChild(generateNode, app);
```


## v2 - vue雏形: 仿照vue实现封装
好了, 到这里, 我们就可以去实现 构造函数了, 这里先给出构造函数的几个方法, 之后我们就把刚刚写的套进去就行了
```javascript

// render 渲染函数, 调用compiler()
// compiler 数据与模板结合, 处理完成后, 调用update
// update 更新函数, 将处理好的DOM结点替换旧的

// 构造函数
function WJYVue(options) {
    // vue 中 内部数据 使用_开头, 只读数据使用 $ 开头
    this._data = options.data;
    this._el = options.el;

    // 准备工作(获得模板)
    this.$el = this._template = document.querySelector(this._el);
    // 用于update 更新页面
    this._parent = this._template.parentNode;

    // 渲染
    this.render();
}

/** 将模板结合数据得到HTML加到页面中 */
WJYVue.prototype.render = function () {
    this.compiler();
};

/** 编译, 将模板与数据结合得到真正的DOM元素 */
WJYVue.prototype.compiler = function () {
    let realHTMLDOM = this._template.cloneNode(true); // 用模板拷贝得到一个DOM
    compiler(realHTMLDOM, this._data);
    // 调用update将编译好的放到页面中
    this.update(realHTMLDOM);
};

function compiler(template, data) {
    // 判断子元素是否是文本节点
    // debugger;
    let childNodes = template.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
        /**判断什么呢?这里先打个断点看看 #app下所有的内容**/
        /* 可以看到,我们现在的案例中, {{}} 是在text标签下的,那么我们就可以递归去找
                text标签,然后拿到 {{}} 这个后,再来进行处理
                * text
                    data: "{{ message }}"
                    length: 13
                    nodeName: "#text"
                    nodeType: 3
                    nodeValue: "{{ message }}"
                * */

        let type = childNodes[i].nodeType;
        // debugger;
        if (type === 3) {
            // 文本
            let txt = childNodes[i].nodeValue; // 获取到内容
            // console.log(txt);
            let reg = /\{\{(.+?)\}\}/g;
            /** 处理模板字符串内容**/
            // 获取到{{}}里的内容的正则表达式: /\{\{(.+?)\}\}/g
            // 然后拿到这个值后就基本上可以去 data中用类似这种data['name']形式去获取值
            // 然后这里可以用replace来替换
            txt = txt.replace(reg, function (_, g) {
                console.log(g);
                let key = g.trim();
                let value = data[key];
                return value;
            });
            childNodes[i].nodeValue = txt;
        } else {
            /** 什么时候递归下一个呢?**/
            // 在nodeType 里, 为1的话表示元素, 即当 nodeType = 1 时,我们递归
            compiler(childNodes[i], data);
        }
    }
}

/** 更新, 将DOM元素 放到页面中 */
WJYVue.prototype.update = function (real) {
    // 替换到页面当中
    this._parent.replaceChild(real, document.querySelector(this._el));
};

/**用法*/
let app = new WJYVue({
    el: "#app",
    data: {
        name: "wjygrit",
        message: "实现 数据的填充",
    },
});

```

## v3 - 实现`x.y.z`的深度访问
这部分也不麻烦, 就是把 `x.y.z` 以 `.` 拆分, 然后遍历获取值即可
```javascript
 // 使用xxx.xxx获取值
      function getValueByPath(obj, path) {
        let paths = path.split("."); // [xx.xx]
        let res = obj;
        while ((prop = paths.shift())) {
          res = res[prop];
        }
        return res;
      }
```


## v4 - 虚拟DOM

## v5 - 使用柯里化优化

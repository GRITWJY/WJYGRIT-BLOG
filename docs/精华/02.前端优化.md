---
title: 前端优化  
date: 2022-08-31 15:35:34  
permalink: /pages/delicate/optimize
categories:
  - 前端
  - 知识体系
  - 精华
tags:
  - 精华
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 02.前端优化

## 简述
关于前端优化这个问题， 想必大家都能说出一堆来， 在网上也有很多相关的博客。 

但， 网上总结的太松散了， 面试时一回答就清楚是八股文。 这里就根据自己的实际情况 做一个 完整的总结。 


## 起因

最开始关注性能问题是由于 项目第一次上线的时候， 是 `900` 多人同时登录系统， 当时直接就崩溃了， 而且当时对于并发方面也没有做一些
防范措施， 导致后来花了很多时间修改bug。 

后来就从前后端代码、 项目部署等各个环节 去了解常见的性能优化手段， 最终是成功渡过了 `第二学期的高峰期`


## 总览

本篇文章分为以下几个部分：

- 检测性能

- 加载时优化
  - 组件化
  - webpack
  - CDN
  - 负载均衡

- 请求优化
  - 合并请求
  - mysql优化
  
- 运行时优化
  - 渲染
  - 缓存
  - 重绘与回流
  - 懒加载  
  - 并发

[[toc]]


## 检测性能

关于性能的监测， 最开始我就是用的 `chrome` 的 `lighthouse`， 每次检测一个页面， 然后优化完后再检测， 对比两次的分数，一直这样把系统的20几个页面都检测完了。

关于它的指标介绍， 在之后的前端监控SDK设计的文章里会介绍


## 加载时性能优化

### 组件化

这里说一下为什么我把组件化放这里， 系统中的第一版代码是完全没有组件的概念的， 一个vue文件就包含了这整个页面所有的布局和逻辑， 一个文件至少都得八九百行起步。。。。。

后来也是因为测试的时候分数太低了， 同时自己也了解了组件化的概念， 自己就把对系统整体做了个拆分， 最后是把每个页面的分数提到了90以上， 除了个别页面是80+。

这里就说一下开发一个组件的方法吧， 看有些面试官会考， 以 `dialog` 为例：

- 1. 确认基本结构.
  比如 `dialog` 包括中间的 `弹框` 和 `遮罩层`。 然后 `弹框` 又分为 `头、中、底` 三个部分。 这就是最基本的结构了
  
- 2. 确认实际**结构的个性化需求**
  接下来确认个性化结构， 比如
    - 头部需要有 `左侧标题` 和 `右侧按钮`， 及是否可自定义的， 在vue中就是 `template slot`
    - 中间....
    - 底部....
    - 遮罩层...
  
- 3. 确定事件
  以上就是把这个组件的结构确定下来了， 接下来就可以写事件了
    - 显示，隐藏的事件
    - 遮罩层事件
    - 默认按钮事件
    
- 4. 其他需求
  到这里， 一个组件基本上就已经完成了， 也可以正常使用了。 但可能还会有一些其他需求， 比如
    - 显示和隐藏需要动画
    - 遮罩层开启后， body 不能滚动
    - 弹框大小和位置可控制
    - 有时还会有颜色的要求， 间距，等要求 。。。。。


### CDN

内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间

**访问流程**

浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。

本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。

本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。

SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。

浏览器再根据 SLB 发回的地址重定向到缓存服务器。

如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。



**CDN功能**
- **1.静态加速能力。** 通过本地化缓存加速能力给用户提供一个尽力而为的就近访问的高性能访问架构，将用户 访问的内容缓存在边缘节点上，消除由用户地域差异而导致的用户体验不一致，提供不同地区 用户的相对一致的高性能访问体验。
- **2.卸载源站能力。** CDN将资源缓存在它的服务器上，访问是在用户和CDN之间进行的，原来用户的直接请 求都发送到网站服务器上，移交到CDN上后，源站的访问量和带宽占用都会大幅度减小。特 别是对大型网站而言，图片等静态资源占了网站所有请求的90%以上。图片访问量对于大型网 站来说是巨大的，服务器要提供具备相应吞吐能力的服务，其架构设计、运维规划、监控和预 警要十分完善，否则很容易出现稳定性问题。后面将会介绍CDN命中率突然变低，造成源站 出现各种不稳定的问题；也可以看到，CDN的命中率对于减小源站的压力十分关键。总而言之， CDN的存在大大减小了源站的压力，提高了网站的稳定性。
- **3.防攻击能力。** 一般比较成熟的CDN提供商至少有数百个CDN节点，甚至数千个，而把资源放在CDN 上，对网站的恶意攻击大部分都会将目标放到CDN节点上，CDN是一个天然的跨地区甚至跨 洲的大型分布式系统。大量CDN节点的存在，可以有效地将攻击由中心化分散到CDN的边缘 上，从而有效地阻止或者减小攻击造成的危害。
- **4.动态加速能力。** CDN提供静态加速能力的原理是通过将资源缓存在CDN边缘节点上，让用户访问资源的 网络距离变短，从而实现性能的优化。CDN不仅适用于可缓存资源的静态加速，而且可以用于 动态请求的加速，其原理是通过7层路由路径的优选，克服BGP选路的缺点，实现动态加速能 力


### 负载均衡




负载均衡算法决定了负载均衡服务器如何将一个请求分配给后面的诸多服务器。

1. **轮询算法(Round Robin) 和 加权轮询（Weight Round Robin）法:** 轮转法意味着 LB 服务器会按顺序将请求分发给服务器。比如负载均衡器会将第一个请求分配给第一个服务器，然后下一个请求分配给第二个服务器，这样分配下去分配完一轮之后回到开头分配给第一个服务器。

不同的服务器可能机器配置和当前系统的负载并不相同，因此它们的抗压能力也不尽相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求，而低配置、高负载的机器，则给其分配较低的权重，降低其系统负载。加权轮询法可以很好地处理这一问题，并将请求顺序按照权重分配到后端。

**2. 随机法 和 加权随机（Weight Random）法：** 很粗糙的方法，通过生成随机数，将连接随便转发给后端的一个服务器，当访问量加大，实际效果接近于平均分配流量到每一台后端服务器，也就是轮询的效果。

与加权轮询法类似，加权随机法也是根据后端服务器不同的配置和负载情况来配置不同的权重。不同的是，它是按照权重来随机选择服务器的，而不是顺序。

**3. 最少连接(Least Connections):** 最少连接方法会选择当前连接数量最少的服务器分发请求。

前面几种方法费尽心思来实现服务消费者请求次数分配的均衡，当然这么做是没错的，可以为后端的多台服务器平均分配工作量，最大程度地提高服务器的利用率但是实际情况是否真的如此？
实际情况中，请求次数的均衡真的能代表负载的均衡吗？这是一个值得思考的问题。上面的问题，再换一个角度来说就是：以后端服务器的视角来观察系统的负载，而非请求发起方来观察。最小连接数法便属于此类。最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它正是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前请求，尽可能地提高后端服务器的利用效率，将负载合理地分流到每一台机器。

**4. Source 原地址法:** 源地址hash，新连接先按权重分配，后续连接按source分配请求。起到会话绑定的作用，但是调度粒度太粗，使用的少，相当于是ip_hash.





### webpack

[关于 `webpack` 的优化配置， 建议看这个连接](https://yk2012.github.io/sgg_webpack5/senior/)
有以下几点
- 1. 提升开发体验
- 2. 提升打包构建速度
- 3. 减少代码体积
- 4. 优化代码运行性能
  



## 请求优化

### 合并请求
这个主要目的是减少请求， 就拿我自己的例子来说， 高峰时期学生的操作只有三步  `登录， 选择实验课表， 选课`， 其实就可以简化成3个接口（以前是用了好几个接口哈）。

还有像其他的一些比如说减少静态资源的请求啥的， 这个就根据实际情况了。


### mysql 优化
请求方面其实还有个问题， 那就是接口请求。 之前数据较少， 没怎么加索引， 也导致了一次差点崩溃的情况。 

我当时就是 用 `explain` 把项目中接近`100`个接口一一测试， 最后是得到了一个比较完整的方案哈， 说下具体例子：

有一个导出所有学生数据的接口， 之前索引加的不怎么好， 要一分多钟才能查询完(基本上有二十几万条数据吧)， 经过多次优化后， 最后只用了10s左右。


[关于`mysql优化的` ， 可以看看这篇文章](https://www.wjygrit.cn/pages/APISLOW)



## 运行时优化

### 从渲染原理出发
这里先详细说下 **构建DOM、样式计算**这2个步骤。

- 1.  预解析HTML，预加载link和script外链。现代浏览器对外链加载做了优化，会在渲染进程接收到HTML数据字节流时候就开始预解析HTML，预解析会找到HTML中的外链并交给下载进程提前加载。
- 2. 解析HTML，构建DOM。
- 3. 遇到style标签或者link外链加载好后，解析CSS，构建CSSOM。
- 4. 遇到script标签，停止解析HTML，等待外链CSS加载并解析完成、内联CSS解析完成后，再执行JavaScript。执行完JavaScript再开始解析HTML。如果外链的script标签有defer/async属性，则该script标签的下载和执行时候不会停止解析HTML。若存在defer属性，JavaScript会等DOMContentLoaded事件触发后再开始执行；若存在async属性，JavaScript会等下载完再执行。动态创建的标签也会在下载完成后再执行。



**阻塞的总结**
- ● css解析会阻塞渲染。因为构造渲染树需要CSSOM，因此CSS解析完成是后续工作的先决条件。
- ● css下载会阻塞js执行，不会阻塞html解析。
- ● js下载和执行会阻塞html。
- ● 在执行 JavaScript 脚本之前，会先加载并解析页面中的CSS样式（包括link标签和style标签）（如果存在）。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。
- ● defer的js会异步下载执行，不阻塞HTML解析。
- ● async的js会异步下载，下载完执行，即下载不阻塞HTML解析，但执行阻塞HTML解析。


**两个原则**
- 1. 尽量避免阻塞
- 2. 缩短阻塞时间

如何缩短阻塞时间呢？有2个原则：尽可能少、尽可能早。

资源量尽可能少（压缩、雪碧图、按需加载）、请求次数尽可能少（打包）、让无依赖关系的资源尽可能早加载而不是等待排队（域名打散、分包，即并行）、请求链路尽可能少（CDN）

尽可能早解析DNS（DNS预解析）


因此样式资源放在head标签中，这样并不会造成不必要的阻塞，并且代码会更规整；JavaScript应该放在body底部或者加上defer/async属性或者动态创建script标签（动态创建的script标签外链会异步加载）避免JavaScript的下载执行阻塞HTML的解析。


CSS：使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。`尽量避免使用@import`它们之间的区别：

- link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
- @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
- style：GUI直接渲染


### 重绘与回流

首先大概了解浏览器的渲染机制

- 浏览器采用流式布局模型，对渲染树的计算通常只需要遍历一次就可以完成
- 浏览器会将HTML解析成DOM,把CSS解析成CSSOM ,两者结合产生render tree
- 有了render tree 知道了节点样式，然后浏览器会计算节点的位置，把节点绘制在页面上

重绘：通俗来讲就是渲染树中的元素需要更新的属性只影响元素的外观，不影响布局称为重绘

回流（重排）：元素的规模尺寸，位置，隐藏等改变需要重新构建的操作会影响到布局称为回流。

触发回流的条件：
- 1.页面渲染初始化（不可避免地）
- 2.浏览器窗口改变尺寸，元素改变尺寸，元素位置改变，元素内容改变；添加、删除可见DOM元素

减少回流的操作：
- 1.离线修改DOM,使用文档碎片
- 2.不要使用table 布局
- 3.不要一条一条修改DOM样式，预先定义好CSS的] class ,修改dM的IclassName
- 4.需要多次回流的元素将其设置为absolute 或cfixed ,脱离了文档流就不会影响其他元素


现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。**



### 缓存


- 对静态组件：通过设置 Expires 头部来实现永不过期策略。
- 对动态组件：用合适的 Cache-Control 头部来帮助浏览器进行有条件性的请求。


在常用的缓存是 Cache-control
```shell
nginx:
location ~ .*\.(css|js|swf|php|htm|html )$ {
  add_header Cache-Control no-store;
}
```

对于站点中不经常修改的静态内容（如图片，JS，CSS），可以在服务器中设置expires过期时间，控制浏览器缓存，达到有效减小带宽流量，降低服务器压力的目的。
```shell
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {
  #过期时间为30天，
  #图片文件不怎么更新，过期可以设大一点，
  #如果频繁更新，则可以设置得小一点。
  expires 30d;
}
location ~ .*\.(js|css)$ {
  expires 10d;
}
```
Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。


**Cache-control策略**
Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。

**http协议头Cache-Control ：**

值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age

各个消息中的指令含义如下：

- Public指示响应可被任何缓存区缓存。
- Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
- no-cache指示请求或响应消息不能缓存
- no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
- max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
- min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
- max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。


**Last-Modified/If-Modified-Since**


- Last-Modified/If-Modified-Since要配合Cache-Control使用。
- Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
- If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。



#### 强制缓存
   <img :src="$withBase('/keomkdw/img.png')" alt="foo"/>

   <img :src="$withBase('/keomkdw/img1.png')" alt="foo"/>

##### 协商缓存(对比缓存)
是一种服务端缓存策略。主要是资源有个标识，用来检查缓存与最新版本是否相同，用于网站更新

   <img :src="$withBase('/keomkdw/img2.png')" alt="foo"/>

   <img :src="$withBase('/keomkdw/img3.png')" alt="foo"/>


#### 协商缓存中的标识
- last-midified: 资源上一次修改的时间

    <img :src="$withBase('/keomkdw/img4.png')" alt="foo"/>

    <img :src="$withBase('/keomkdw/img5.png')" alt="foo"/>


- etag：资源对应的唯一字符串

    <img :src="$withBase('/keomkdw/img6.png')" alt="foo"/>

    <img :src="$withBase('/keomkdw/img7.png')" alt="foo"/>


#### 总结
- 首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存
- 如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：
  - 若资源更新，那么返回资源和 200 状态码
  - 如果资源未更新，那么告诉浏览器直接使用缓存获取资源


<img :src="$withBase('/keomkdw/img8.png')" alt="foo"/>


### 懒加载

- 图片懒加载
如果想看原理，可以看我的这边博客[图片懒加载](http://www.wjygrit.cn/pages/RLWMCP)

- vue-Router 懒加载原理

关于 `vue-Router` 的懒加载需要结合打包工具`webpack` 一起讲解， 这里我讲解前半部分的， 后半部分在我的这个文章里 [《webpack模块打包原理》](https://www.wjygrit.cn/pages/OEKENR/)

`vueRouter` 懒加载其实就是用的 `import()`， 没其他的了， 然后具体的实现， 还是得靠 `webpack`. 

简单概括就是用 `jsonp` 的方式实现懒加载

### 并发问题

目前只考虑了前端的并发问题， 后端的待到今年年底更新。

前端的主要是减少恶意请求去的， 具体的看我这两篇的博客。


- [axios取消请求、重试、缓存](https://www.wjygrit.cn/pages/kaowmka)
- [控制多次点击只触发一次](https://www.wjygrit.cn/pages/or2ksam/) 
- [前端一次性导入3K+数据](https://www.wjygrit.cn/pages/akcmne3)


## 总结

基本上所有的性能优化就是这些了， 还有些小的点也是包括在这里的。

- [负载均衡](https://juejin.cn/post/6844904083967442951)
- [webpack 配置](https://yk2012.github.io/sgg_webpack5/senior/optimizePerformance.html#code-split)
- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327/answer/193768864)
- [CDN原理解析](https://juejin.cn/post/6844903873518239752)
- [使用JS添加交互](https://web.dev/critical-rendering-path-adding-interactivity-with-javascript/)
- [webpackChain配置](https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans)
- [每个前端都必须要学会的Webpack优化手段](https://juejin.cn/post/7083519723484708878#heading-11)
- [Vue项目优化打包——前端加分项](https://juejin.cn/post/7004045635620405278)
- [我用webpack把公司的老项目做了下优化](https://juejin.cn/post/7072012773730811941#heading-8)
- [前端缓存最佳实践](https://juejin.cn/post/6844903737538920462)
- [彻底弄懂前端缓存](https://juejin.cn/post/7052527032491573279#heading-5)
- [(建议收藏)为什么第二次打开页面快？五步吃透前端缓存，让页面飞起](https://juejin.cn/post/6993358764481085453#heading-10)
- [Nginx代理缓存机制](https://juejin.cn/post/7036281834728554533)
- [前端项目常规性能规划](https://juejin.cn/post/7080066104613142559#heading-2)

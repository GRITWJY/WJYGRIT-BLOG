---
title: 安全性  
date: 2022-08-31 18:04:34  
permalink: /pages/delicate/safe/  
categories:
  - 前端
  - 知识体系
  - 精华
tags:
  - 精华
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 04.安全性

关于安全性， 这里主要介绍 `XSS` 和 `CSRF`攻击， 然后其他的一些主要是通过 `CSP这个字段` 来进行补充

[除了浏览器安全， 还有`重放攻击、 登录鉴权、 数据加密、 单点登录、登录时长` 的前后端方案](https://www.wjygrit.cn/pages/KEOMXW)



## 分类
- 页面安全
  - [同源策略](https://www.wjygrit.cn/pages/CHEWO/#_12-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B9%8B-jsonp)
  - XSS
  - CSRF

- 浏览器网络安全

- 浏览器系统安全


## 1. 什么是 XSS 攻击?

### 1> 概念
`XSS 攻击指的是跨站脚本攻击`，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

`XSS 的本质是因为网站没有对恶意代码进行过滤，`与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。


攻击者可以通过这种攻击方式可以进行以下操作：

- 获取页面的数据，如DOM、cookie、localStorage；
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
- 破坏页面结构；
- `流量劫持（将链接指向某网站）；`

### 2> 类型

**1）存储型 XSS 的攻击步骤：**

- 攻击者将恶意代码提交到⽬标⽹站的数据库中。
- ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
- ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
- 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。


**2）反射型 XSS 的攻击步骤：**

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
- ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
- 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。


反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。

反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。

**3）DOM 型 XSS 的攻击步骤：**

- 攻击者构造出特殊的 URL，其中包含恶意代码。
- ⽤户打开带有恶意代码的 URL。
- ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。
- 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。


### 如何防御 XSS 攻击？

- 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好`充分的转义`。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
- `使用 CSP` ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。



## 2.什么是 CSRF 攻击？

`CSRF跨站点请求伪造（Cross Site Request Forgery）`和XSS攻击一样，有巨大的危害性，就是攻击者盗用了用户的身份，以用户的身份发送恶意请求，但是对服务器来说这个请求是合理的，这样就完成了攻击者的目标。

**CSRF攻击的过程原理是：**

- 用户打开浏览器，访问目标网站A，输入用户名和密码请求登录

- 用户信息在通过认证后，网站A产生一个cookie信息返回给浏览器，这个时候用户以可正常发送请求到网站A

- 用户在没有退出网站A之前在同一个浏览器打开了另一个新网站B。

- 新网站B收到用户请求之后返回一些攻击代码，并发出一个请求要求访问返回cookie的网站A

- 浏览器收到这些攻击性代码之后根据新网站B的请求在用户不知道的情况下以用户的权限操作了cookie并向网站A服务器发起了合法的请求。

**预防CSRF攻击主要有以下策略：**

- 使用验证码，在表单中添加一个随机的数字或者字母验证码，强制要求用户和应用进行直接的交互。

- HTTP中Referer字段，检查是不是从正确的域名访问过来，它记录了HTTP请求的来源地址。

- 使用token验证，在HTTP请求头中添加token字段，并且在服务器端建立一个拦截器验证这个token，如果token不对，就拒绝这个请求。



注意: 验证HTTP Referer字段的好处就是实施起来特别简单，普通的网站开发不需要特别担心CSRF漏洞，只需要在最后面设置一个拦截器来验证referer的值就可以了，不需要改变已有的代码逻辑，非常便捷。但是这个方法也不是万无一失的，虽然referer是浏览器提供的，但是不同的浏览器可能在referer的实现上或多或少有自身的漏洞，所以使用referer的安全保证是通过浏览器实现的。使用token验证的方法要比referer更安全一些，需要把token放在一个HTTP自定义的请求头部中，解决了使用get或者post传参的不便性。



## 3. [流量劫持](https://juejin.cn/post/6844903697428774926#heading-17)


## 4. 关于Web密码学你了解哪些呢？

- 对称加密算法
  - 对称加密算法就是加密和解密使用同一个密钥，简单粗暴
  - 常见的经典对称加密算法有 `DES、AES(AES-128)、IDEA、国密SM1、国密SM4`

- 非对称加密算法
  - 非对称加密就是加密和解密使用不同的密钥。发送方使用公钥对信息进行加密，接收方收到密文后，使用私钥进行解密。 
  - 主要解决了密钥分发的难题
  - 我们常说的签名就是私钥加密
  - 常见的经典非对称加密算法有`RSA、ECC和国密SM2`

- 散列算法
  - 不可逆性、鲁棒性、唯一性
  - `MD5、SHA(SHA-256)、国密SM3` 
  - 使用时记得加盐

AES 是国际上最认可的密码学算法，只要算力没有极大的突破性进展，这种算法在可预期的未来都是安全的。

ECC 是目前国际上加密强度最高的非对称加密算法。

MD5 和 SHA 的唯一性被*解了，但是大部分场景下，不会构成安全问题。一般使用 SHA-256 加盐即可满足大部分使用场景。


## 简单说一下HTTPS的实现原理

- 1. Client 发送 `random1+对称加密套件列表+非对称加密套件列表` 
- 2. Server 收到信息， 选择 `对称加密套件+非对称加密套件 并和 random2+证书(公钥在证书中)` 一起返回 
- 3. Client 验证证书有效性，并用 `random1+random2 生成 pre-master 通过服务器公钥加密+浏览器确认` 发送给 Server
- 4. Server 收到 pre-master，`根据约定的加密算法对 random1+random2+pre-master（解密）生成 master-secret，然后发送服务器确认` 
- 5.Client 收到生成同样的 master-secert，对称加密秘钥传输完毕


HTTPS 在 TCP 和 HTTP 中间加入了 SSL/TLS 安全层。

对发起 HTTP 请求的数据进行加密操作对接收到 HTTP 的内容进行解密操作。

采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，既可以解决传输效率问题也能保证两端数据的安全传输。除此之外，为了能够证明服务器是可靠的，引入了数字证书，让浏览器验证证书的可靠性。

## cookie 与 安全

### cookie的作用

因为**http请求是无状态**的，不会记忆之前的信息，前后两次请求是没有关系的。而有些请求需要记录状态，就需要通过Cookie携带信息发送到服务器，从而返回不一样的回应。

**cookie是服务器保存在浏览器的一块文本信息**，浏览器每次向服务器发出请求，就会**自动**附带这段信息。

### cookie 的属性

**1. expires, max-age**

- Expires：具体的到期时间。过期后，浏览器就不再保留这个cookie。
- Max-Age：从现在开始cookie存在的秒数，优先级高于Expires。
- 不设置/null：cookie只在当前会话存在，浏览器窗口关闭后，当前session结束，cookie就被删除。




**2. Domain，Path**
- （1）Domain：**指定cookie属于哪个域名**。以后浏览器向服务器发送请求时，通过该属性判断是否要携带cookie。默认为当前域名。

- （2）Domian属性的规则：Domain属性只能是**当前域名或当前域名的上级域名**，**且不能是顶级域名或公共域名**，否则浏览器会拒绝设置该cookie。----浏览器发送cookie时，Domain属性必须是当前域名或其上级域名。

- （3）Path：指定**浏览器发送http请求时，哪些路径要附带这个cookie**。只要Path属性是**请求路径的开头一部分**，就会在头信息中带上这个cookie。（前提是Domain符合条件）


**3. Secure，HttpOnly**

- （1）Secure：指定浏览器只有在`https`协议下（当设置为true时），才能将`cookie`发送到服务器。如果当前协议是http，则会忽略secure属性。

- （2）HttpOnly：指定该`cookie`无法通过`JS脚本`拿到，例如`document.cookie、XMLHttpRequest`对象都拿不到该属性，只有浏览器发送http请求时才会带上该cookie。`可以防止xss攻击，不让cookie被脚本读到`。


**4. samesite**


- （1）用来防止用户追踪和防止csrf攻击。

- （2）第三方cookie：由第三方网站引导而附带发送的cookie。它不仅会导致csrf攻击，还能用于用户追踪（facebook网站在第三方网站插入一张图片，当浏览器执行该部分代码时，就会向facebook发送带cookie的请求，从而让facebook知道了你是谁，访问了什么网站）。

- （3）可以设置的3个值，来限制第三方cookie。
  - Strict：禁止第三方cookie。跨站点时，任何情况下都不会发送cookie。
  - Lax：大多情况下也是禁止第三方cookie，但是导航到目标网站的get请求（包含链接、get表单等）除外。默认值
  - None：关闭SameSite属性，前提是同时设置secure属性，否则无效。



### cookie 与跨域

默认情况下，浏览器对跨域请求不会携带Cookie,但鉴于Cookie在身份验证等方面的重要性，**CORS推荐使用额外的响应头字段来允许跨域发送Cookie**，因此，CORS本质是W3C指定的一套规范，主流浏览器通过查看服务端返回的协议头，来确定是否准许跨域携带Cookie。



- `Access-Control-Allow-Origin：*`，  该字段是必需的，它的值要么是请求时Origin字段的值，要么是一个 * ，**表示接受任意域名的请求**

- `Access-Control-Allow-Credentials：true`， 该字段可选，它的值是一个布尔值，表示是否允许发送`Cookie`。`默认情况下Cookie，Cookie不包括在CORS请求中`。设为 TRUE ，即表示服务器明确许可，Cookie可以包含在请求中。
  - 另一方面，开发者必须在`AJAX`请求中打开`withCredentials`属性。
  - **需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。**
- `Access-Control-Expose-Headers：`,  默认情况下，只有七种 `simple response headers （简单响应首部）`可以暴露给外部：`Cache-Control，Content-Language，Content-Length，Content-Type，Expires，Last-Modified，Pragma`。如果想要让客户端可以访问到其他的首部信息，可以将它们在 `Access-Control-Expose-Headers` 里面列出来。
- `Access-Control-Request-Method：`, 该字段是必需的，响应首部 `Access-Control-Allow-Methods`，明确了客户端所要访问的资源允许使用的方法或方法列表。
- `Access-Control-Request-Headers：`, 请求头 `Access-Control-Request-Headers` 用于通知服务器在真正的请求中会采用哪些请求头。
- `Access-Control-Allow-Headers：`, 该字段是必需的，允许哪些请求头可以跨域

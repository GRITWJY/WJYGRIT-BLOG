---
title: TCP原理解读
date: 2022-05-09 12:53:37
permalink: /pages/aFADfdfasFAFA61298/
categories:
  - 计算机
  - 计算机网络
tags:
  - TCP  
author: WJYGRIT
---



# TCP

## 1、什么是TCP网络分层

> 应用层(数据包)-> 传输层(TCP头部，端口，序列号等) -> 网络层(IP头部，IP地址) -> 数据链路层(MAC地址)->物理层

<img :src="$withBase('/img_36.png')" alt="foo"/>

<img :src="$withBase('/img_37.png')" alt="foo"/>

## 2、TCP的三次握手为什么是3次

<img :src="$withBase('/img_38.png')" alt="foo"/>
从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。

- 1、然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态
- 2、服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。
- 3、之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。

**为什么不是两次**
- 因为无法确认客户端的接收能力

**为什么不是四次**
- 三次握手的目的是确认双方发送和接收的能力，三次足够

## 3、 四次挥手
<img :src="$withBase('/img_39.png')" alt="foo"/>
刚开始双方处于ESTABLISHED状态
- 客户端要断开了，向服务器发送 FIN 报文，发送后客户端变成了FIN-WAIT-1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。
- 服务端接收后向客户端确认，变成了CLOSED-WAIT状态。
- 客户端接收到了服务端的确认，变成了FIN-WAIT2状态。
- 随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，
- 客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。

**为什么是四次挥手而不是三次？**
- 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。

## 4、 为什么SYN/FIN 不包含数据却要消耗一个序列号
>凡是需要对端确认的，一定消耗TCP报文的序列号。
<img :src="$withBase('/img_40.png')" alt="foo"/>

## 5、 什么是半连接队列？什么是SYN Flood攻击？

- 半连接队列
  - 当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。
- 全连接队列
  - 当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。


<img :src="$withBase('/img_41.png')" alt="foo"/>

- 如何应对 SYN Flood 攻击？
  - 增加 SYN 连接，也就是增加半连接队列的容量。
  - 减少 SYN + ACK 重试次数，避免大量的超时重发。
  - 利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。

## 6、TCP快速打开(TFO)的原理
<img :src="$withBase('/img_42.png')" alt="foo"/>
<img :src="$withBase('/img_43.png')" alt="foo"/>
<img :src="$withBase('/img_45.png')" alt="foo"/>
<img :src="$withBase('/img_46.png')" alt="foo"/>

**后面的三次握手**
- 在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。
- 重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。

**TFO 的优势**
- TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。


## tcp发送报文数据时，可能将多个数据包合并成一个大的数据包发送，就有可能发生粘包问题。以下可以用来解决这个问题的是？
出现粘包，主要是tcp为了提高效率，每次都要等足够长的数据才进行发送，接收方要等到足够长的数据才从缓冲区提取。解决的办法就是只要能把包分开就不影响传输。
- 发送固定长度的消息
- 包结尾增加分隔符
- 把消息分成消息头和消息体，其中消息头上包含长度
- 慢开始算法和利用滑动窗口实现控制都是网络数据传输时的流量控制，以避免拥塞的发生的算法

## 进程从运行状态进入就绪状态的原因可能是
<img :src="$withBase('/TCP/img.png')" alt="foo"/>

## 7、TCP报文中的时间戳有什么作用？

<img :src="$withBase('/TCP/img_2.png')" alt="foo"/>
TCP TimeStamps Options由四部分构成：类别，长度，发送方时间戳，回显时间戳

**解决两大问题**
- 计算往返时延RTT：ACK包括了TSval 和 TSecr，这样无论是正常确认包韩式重传确认包，都可以通过这两个值计算出RTT
- 防止序列回绕：

<img :src="$withBase('/TCP/img_3.png')" alt="foo"/>
<img :src="$withBase('/TCP/img_4.png')" alt="foo"/>


## 8、TCP的超时重传时间是如何计算的？
<img :src="$withBase('/TCP/img_5.png')" alt="foo"/>
<img :src="$withBase('/TCP/img_6.png')" alt="foo"/>
<img :src="$withBase('/TCP/img_7.png')" alt="foo"/>

## 9、TCP的流量控制？
<img :src="$withBase('/TCP/img_8.png')" alt="foo"/>
<img :src="$withBase('/TCP/img_9.png')" alt="foo"/>

## 10、TCP的keep-alive的原理
<img :src="$withBase('/TCP/img_10.png')" alt="foo"/>

## 11、TCP当中的端口号
<img :src="$withBase('/TCP/img_11.png')" alt="foo"/>
<img :src="$withBase('/TCP/img_12.png')" alt="foo"/>


## 12、TCP场景问题1
<img :src="$withBase('/TCP/img_13.png')" alt="foo"/>
500 + 300 + 200

## 13、TCP场景问题2
收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议
<img :src="$withBase('/TCP/img_14.png')" alt="foo"/>


## 14、TCP场景问题3
<img :src="$withBase('/TCP/img_15.png')" alt="foo"/>

## 15、telnet使用
<img :src="$withBase('/TCP/img_16.png')" alt="foo"/>

## 16、netstat的用法
<img :src="$withBase('/TCP/img_17.png')" alt="foo"/>

## 17、tcpdump用法
tcpdump则是一个命令行的网络流量分析工具，功能非常强大，一般我们用来抓TCP的包

## 19、TCP和UDP的区别
<img :src="$withBase('/TCP/img_18.png')" alt="foo"/>

## 20、设计QQ？
<img :src="$withBase('/TCP/img_19.png')" alt="foo"/>


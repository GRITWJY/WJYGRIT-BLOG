---
title: HTTP与HTTPS
date: 2022-05-09 09:51:37
permalink: /pages/aFADFAFA61298
categories:
  - 计算机
  - 计算机网络
tags:
  - HTTP
author:
    name: WJYGRIT
    link: https://github.com/GRITWJY
---



# HTTP与HTTPS

## HTTP和HTTPS协议的区别

HTTP和HTTPS协议的主要区别如下：

- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

## HTTP

- `无连接的`无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- `媒体独立的`意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型
- `基于C/S架构模型`，通过一个可靠的连接来交换信息，是一个无状态的请求/响应协议

## GET 和 POST 的请求的区别

- 应用场景： GET 用于获取数据, POST 用于提交数据
- 安全性： GET 将参数放入 url 中，不太安全，因为url 会被保留在历史记录中。
- 报文格式： GET 请求的报文中实体部分为空，POST 请求的报文中实体部分为向发送的数据。
- 请求长度： GET 请求发送数据时的长度会根据浏览器的限制而不同。
- 是否缓存： 浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。
- 参数类型： POST 的参数传递支持更多的数据类型。

## GET 方法 URL 长度限制的原因

实际上 HTTP 协议规范并没有对 GET 方法请求的 url 长度进行限制，是浏览器及服务器的限制。

IE 对 URL 长度的限制是2083字节(2K+35)。由于 IE 浏览器对 URL 长度的允许值是最小的，所以开发过程中，只要 URL 不超过 2083 字节，那么在所有浏览器中工作都不会有问题。

- IE： 2083个字符
- chrome： 8192 个字符
- 其他浏览器： 大于 8192 个字符

## HTTP 1.0 和 HTTP1.1 的区别

- **连接方面：** http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
- **资源请求方面：** 资源请求方面： 在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range
  头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **缓存方面：** 在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如
  Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。 http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0
  中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host
  字段，这样就可以将请求发往到同一台服务器上的不同网站。 http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

- **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。



## HTTP1.0 与 HTTP2.0

HTTP1.x和HTTP2.0主要的区别主要HTTP2.0使用了二进制的数据传输方式、多路复用机制、头部缓存和服务器推送特点。


- `二进制格式（Binary Format）：`HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

- `多路复用（MultiPlexing）：` 连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面。

- `头部压缩：`HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小。

- `服务端推送（server push）：` 如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回。



## HTTP2

- 多路复用。 HTTP 2.0 所有通信都在一个 TCP 连接上完成。
- HTTP 2.0 浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。
- HTTP 2.0 支持服务器到客户端的主动推送机制。
- HTTP/2.0 通过支持首部字段压缩和在同一连接上发送多个并发消息，让应用更有效地利用网络资源，减少感知的延迟时间。

## 对 Keep-Alive 的理解

当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接，这就是长连接。

- 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
- 允许请求和应答的HTTP管线化；
- 降低拥塞控制 （TCP连接减少了）；
- 减少了后续请求的延迟（⽆需再进⾏握⼿）；
- 报告错误⽆需关闭TCP连；
- 长时间的 TCP 连接容易导致系统资源无效占用，浪费系统资源。
- 超出缓存上限使用LRU置换缓存数据


## HTTP中的keep-alive 与多路复用的区别


- `HTTP/1.x` keep-alive 与 HTTP/2 多路复用区别：

- `HTTP/1.x` 是基于文本的，只能整体去传；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送

- `HTTP/1.x keep-alive` 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应

- `HTTP/1.x keep-alive` 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成

- `HTTP/1.x keep-alive` 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应


## 页面有多张图片，HTTP 是怎样的加载表现？

- HTTP 1： 浏览器对一个域名下最大 TCP 连接数为 6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- HTTP 2： 可以一瞬间加载出来很多资源，因为，HTTP2 支持多路复用，可以在一个 TCP 连接中发送多个HTTP 请求。

## 什么是HTTPS协议？

超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS
的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，`而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能`，可以避免此类问题发生。

## TLS/SSL工作原理

TLS/SSL的功能实现主要依赖三类基本算法：`散列函数hash、对称加密、非对称加密`。这三类算法的作用如下：

- 非对称加密 `实现身份认证和密钥协商`
- 对称加密算法采用协商的密钥对 `数据加密`
- 基于散列函数验证  `信息的完整性`



### 非对称加密

`非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。`
之前做的国密SM2的加密就是这种原理，公钥公开，私钥保密。有些系统还会在每天固定时间更新公钥、密钥。

**特点：** 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。

**服务器从CA获取公钥证书， 下发公钥证书给客户端， 客户端通过浏览器内置CA公钥解密该证书得到公钥， 使用该公钥加密数据， 服务器接收到密文并使用自己的私钥解密**

### 对称加密

对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

**特点： ** 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

## 散列函数hash

常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

**特点：**  在信息传输过程中，散列函数不能都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

### 数字证书是什么？

现在的方法**也不一定**是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，**截取了对方发给我们的公钥，** **然后将他自己的公钥发送给我们**
，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA
）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash
算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

<img :src="$withBase('/TCP/img_21.png')" alt="foo"/>

## HTTPS 通信（握手）过程

- 1、客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
- 2、服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
- 3、客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
- 4、服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
- 5、客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

## HTTPS 是如何保证安全的？

结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。

此时⼜带来⼀个问题，中间⼈问题：

如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。

所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的 Hash 算法、证书到期时间等。

但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。

数字签名就是⽤ CA ⾃带的 Hash 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA
的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。


## 为什么 HTTP1.1 不能实现多路复用（腾讯）

`HTTP/1.1` 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

------

`HTTP1.x` 是序列和阻塞机制

`HTTP 2.0` 是多工复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

旧的http1.1是会等 A请求完全处理完后在 处理B请求，会阻塞

另：http1.1已经实现了管道机制：即 在同一个TCP连接里面，客户端可以同时发送多个请求。http 1.0并做不到，所以效率很低

--------

多路复用归功于， HTTP/2 中的 帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。就是在一个 TCP 连接中可以存在多条流。

而Http 1.x 并没有这个标识，每次请求都会建立一次HTTP连接，3次握手4次挥手。


## HTTP 状态码

|类别|原因|描述|
|----|----|----|
|1xx|Information(信息行性态码)|接受的请求正在处理|
|2xx|Success(成功状态码)|请求正常处理完毕|
|3xx|Redirection(重定向状态码)|需要附加操作-完成请求|
|4xx|Client Error(客户端错误状态码)|服务器无法处理请求|
|5xx|Server Error(服务器错误状态码)|服务器处理请求出错|

**200 OK** 表示客户端发来的请求被服务器端正常处理了。

**204 No Content** 表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。

**206 Partial Content** 表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

**301 永久重定向** 表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

- **使用场景**
  - 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。
    其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
  - 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

**302 临时重定向** 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。

- **使用场景**
  - 当我们在做活动时，登录到首页自动重定向，进入活动页面。
  - 未登陆的用户访问用户中心重定向到登录页面。
  - 访问404页面重新定向到首页。

**304 Not Modified 浏览器缓存相关。** 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。




**400 Bad Request** 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

**401 Unauthorized** 表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败, 比如登录失败

**403 Forbidden** 表示请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。

**404 Not Found** 表示服务器上无法找到请求的资源。

**405 Method Not Allowed** 表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下

**500 Internal Server Error** 表示服务器端在执行请求时发生了错误。例如出现了 Bug


**502 Bad Gateway** 表示扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：

**503 Service Unavailable** 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

**504 Gateway Timeout** 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。

## 参考资料

[前端进阶高薪必看-HTTP网络篇](https://juejin.cn/post/7085622765113311269)

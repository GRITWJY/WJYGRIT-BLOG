---
title: 13.算法训练-0904  
date: 2022-09-04 16:58:34  
permalink: /pages/ALG0904/  
categories:
  - 计算机
  - 数据结构
tags:
  - 算法
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 13.算法训练-0904


## 集合的所有子集

:::details
```
问题描述: 集合的所有子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集。示例如下：
输入样例1：nums = [1,2,3] 
输出样例1：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 
输入样例2：nums = [0] 
输出样例2：[[],[0]] 

输入描述: 
1
输入一行，一个字符串，由空格分割 

输出描述: 
1
输出一行，返回所有子集 

输入样例: 
1
1 2 3 

输出样例: 
1
[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

```
:::



## 字符串相乘

:::details
```
问题描述: 
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 

输入：字符串s 
输出：字符串ans 
输入样例1：num1 = "1", num2 = "4" 
输出样例1： "4" 
输入样例2：num1 = "123", num2 = "456" 
输出样例2： "56088" 
说明： 
num1 和 num2 的长度小于110。 
num1 和 num2 只包含数字 0-9。 
num1 和 num2 均不以零开头，除非是数字 0 本身。 
不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 

输入描述: 
1
输入一行，两个字符串，由空格分割 

输出描述: 
1
输出一行，一个字符串 

输入样例: 
1 4 

输出样例: 
4
```
:::


## 颜色分类
:::details
```
【颜色分类】
问题描述: 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排 列。 
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 

输入描述: 
1
输入：数组nums 

输出描述: 
1
输出：数组nums 

输入样例: 
1
2 0 2 1 1 0 

输出样例:
复制代码
1
 [0,0,1,1,2,2]
```
:::


## 罗马数字转整数
:::details
```
【罗马数字转整数】
问题描述: 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M, 分别对应数字：1，5， 10， 50，100，500，1000。例如， 罗马数字 2 写做 II ，即 为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于 大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： 
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 

输入描述: 
1
输入：字符串s 

输出描述: 
1
输出：字符串ans 

输入样例: 
M 

输出样例: 
1000
```

:::

## 五八文字碰碰消
:::details
```
帮帮同学在设计一个文字碰碰消游戏，规定"五"和"八"形成"五八"组合碰到一起即会消除，("八五" 不会消除)。

  例如 "五八", "五八五八", "五五八八"。说明: "五五八八" 是内层的"五八"碰在一起消除后，外层的"五八"会碰在一起消除。

  帮帮同学想知道n个"五"和"八"组成的字符串中，有多少种组合可以满足消除为空字符串。

  现为帮帮同学设计一个方法，输入整数n，表示"五"和"八"的数量，返回n个"五"和n个"八"组成的字符串中，满足消除为空字符串的组合数。
```
```javascript
// 参考：**的22-括号生成 
// 思路：使用回溯记录数量，五看成左括号，八看成右括号
// 不符合的条件的直接剪枝 

/**
 * 输入整数n，返回可消除为空字符串的的n组"五八"字符串数量。
 * @param n int整型 
 * @return int整型
 */
function getTargetNumber(n) {
  let res = 0;
  backtracing(n, n);
  return res;

  function backtracing(fi, ei) {
    if (fi == 0 && ei == 0) {
      res++;
      return;
    }
    if (fi > 0) {
      backtracing(fi - 1, ei);
    }
    // 保证八比五少
    if (ei > fi) {
      backtracing(fi, ei - 1);
    }
  }
}

module.exports = {
  getTargetNumber: getTargetNumber,
};
```
:::



## 质数之手
:::details
```

对于一个正整数 n ，当他被质数之手摸过后，会变成若干个不同的质数，并且这些质数的长度都与 n 相等，
构成其中任意一个质数的数字种类和数量，都和构成 n 的种类和数量相同（即构成这个数的所有数字都是由
原数的每一位构成的）。请你找出 n 被质数之手摸过后，有多少种不同的素数会出现。如果出现了至少一种
素数，请输出其中最小的一个。




输出描述:
第一行输出一个正整数表示有多少种不同的素数。
接下来一行，输出最小的那个素数（如果有的话）。

示例1
输入
90
输出
0
说明
数字前不能有前导0，故不存在一个素数。
示例2
输入
232
输出
1
223
说明
在"223","232","322"这三个数中，只有223为素数。

备注:
Note:如果一个大于1的正整数，除了1和它本身，没有其他的因数，那么我们称它为素数。
```
:::


## 推到多米诺骨牌
:::details
```
链接：https://www.nowcoder.com/questionTerminal/9dfd2d0fdc934cfea2fbf1c688e19382
来源：牛客网

一行中有nn张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。
在开始时，我们同时把一些多米诺骨牌向左或向右推。

每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。
同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡，该骨牌仍然保持不变。
就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。
给定表示初始状态的字符串"S" 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = 'L'；如果第 i 张多米诺骨牌被推向右边，则 S[i] = 'R'；如果第 i 张多米诺骨牌没有被推动，则 S[i] = '.'。
返回表示最终状态的字符串。


示例1
输入
"..LR.."
输出
"LLLRRR"
说明
左边三个都往左倒，右边三个都往右倒
示例2
输入
"R...L"
输出
"RR.LL"
说明
左边2个都往左倒，右边2个都往右倒，中间的保持不变

备注:
1\le n \le 2000001≤n≤200000
```
:::

---
title: 算法题训练-day3  
date: 2022-08-22 07:58:34  
permalink: /pages/ALG-03/  
categories:
  - 计算机
  - 数据结构
tags:
  - 算法
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 算法题训练-day3


## 动态规划训练

### 例题1:  
<img :src= "$withBase( '/ALG-03/img.png' )" alt = "foo"/>

:::details  常规解法
```java

	// 先手情况下 f(arr,L,R) L~R范围上，返回最大分数
		// if L==R, 只有1个数, 直接拿走
		// 拿最大值
			// arr[L] + s(arr, L+1,R) 后手函数
			// arr[R] + s(arr, L, R -1)
			
	// 后手函数 s(arr, L, R)
		// L == R 0
		// 拿最小值
			//   f(arr, L+1,R)
			//   f(arr, L, R-1)
	
	
	public static int f(int[] arr, int i, int j) {
		if (i==j) {
			return arr[i];
		}
		return Math.max(arr[i] + s(arr, i+1, j), arr[j] + s(arr,i,j-1));
	}
	
	public static int s(int[] arr, int i, int j) {
		if (i == j) {
			return 0;
		}
		return Math.min(f(arr,i+1,j), f(arr,i,j-1));
	}
	
	public static int win1(int[] arr) {
		if (arr==null || arr.length == 0) {
			return 0;
		}
		// a,b
		return Math.max(f(arr,0,arr.length - 1), s(arr,0,arr.length - 1));
	}

```
:::


::: details 动态规划
```java
	public static int test1_2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		
		int[][] f = new int[arr.length][arr.length];
		int[][] s = new int[arr.length][arr.length];
		
		
		for (int j = 0; j < arr.length; j++) {
			f[j][j] = arr[j];
			for(int i = j - 1; i >= 0; i--) {
				f[i][j] = Math.max(arr[i] + s[i+1][j], arr[j] + s[i][j-1]);
				s[i][j] = Math.max(f[i+1][j], f[i][j-1]);
			}
		}
		return Math.max(f[0][arr.length - 1], s[0][arr.length - 1]);
		
	}
```
:::


### 例题2: 三维dp
一个棋盘， 马在(0,0)， 到r,c， 必须跳k步， 有几种

:::details 常规解法
```java
public static int test2(int x, int y, int step) {
		// 越界
		if (x < 0 || x > 8 || y < 0 || y > 9) {
			return 0;
		}
		
		// 从 x, y 开始出发， 看结果是否在0,0
		if (step == 0) {
			return (x == 0 && y == 0) ? 1 : 0;
		}
		
		// 8个方向
		return test2(x - 1, y + 2, step - 1) 
				+ test2(x - 1, y + 2, step - 1)
				+ test2(x + 1, y + 2, step - 1)
				+ test2(x + 1, y - 2, step - 1)
				+ test2(x + 2, y + 1, step - 1)
				+ test2(x + 2, y - 1, step - 1)
				+ test2(x + 2, y + 1, step - 1)
				+ test2(x + 2, y - 1, step - 1);
	}
```
:::


:::details 三维dp
```java
public static int test2_dp(int x, int y, int step) {
		if (x < 0 || x > 8 || y < 0 || y > 9 || step < 0) {
			return 0;
		}
		
		
		int[][][] dp = new int[0][10][step+1];
		
		// 第0层， 0,0位置是1
		dp[0][0][0] = 1;
		
		
		// 从1层开始， 到step
		for (int h = 0; h <= step; h++) {
			for(int r = 0; r < 9; r++) {
				for (int c = 0; c < 10; c++) {
					// 8个位置的累加
					dp[r][c][h] += getValue(dp, r - 1, c + 2, h - 1);
					dp[r][c][h] += getValue(dp, r + 1, c + 2, h - 1);
					dp[r][c][h] += getValue(dp, r + 2, c + 1, h - 1);
					dp[r][c][h] += getValue(dp, r + 2, c - 1, h - 1);
					dp[r][c][h] += getValue(dp, r + 1, c - 2, h - 1);
					dp[r][c][h] += getValue(dp, r - 1, c - 2, h - 1);
					dp[r][c][h] += getValue(dp, r - 2, c - 1, h - 1);
					dp[r][c][h] += getValue(dp, r - 2, c + 1, h - 1);
				}
			}
		}
		
		return dp[x][y][step];
	}
	
	public static int getValue(int[][][] dp, int row, int col, int step) {
		if (row < 0 || row > 8 || col < 0 || col > 9) {
			return 0;
		}
		
		return dp[row][col][step];
	}
```
:::


### 例题3:
` [3,5,10] 面值, 任意张, 组成 aim , 最终方法数`

:::details 递归尝试
```java
public static int test4(int[] arr, int index, int rest) {
		if (index == arr.length) {
			return rest == 0 ? 1 : 0;
		}
		
		int ways = 0;
		for (int i = 0; arr[index] * i <= rest; i++) {
			ways += test4(arr, index + 1, rest - arr[index]*i);
		}
		return ways;
	}
	

```
:::

:::details 动态规划
```java
// 递归
	public static int test4_dp(int[] arr, int aim) {
		int N = arr.length;
		int[][] dp = new int[N + 1][aim + 1];
		dp[N][0] = 1;
		
		for(int index= N - 1; index >= 0; index--) {
			for(int rest = 0; rest <= aim; rest++) {
				
				//int ways = 0;
				//for (int i = 0; arr[index] * i <= rest; i++) {
				//	ways += dp[index + 1][rest-arr[index]*i];
				//}
				
				// = 下一个格子和旁边的格子
				dp[index][rest] = dp[index + 1][rest];
				if (rest - arr[index] >= 0) {
					dp[index][rest] += dp[index][rest - arr[index]];
				}
			}
		}
		
		
		return dp[0][aim];
	}

```
:::


## 例题3: 二叉树中最大路径和
<img :src= "$withBase( '/ALG-03/img_1.png' )" alt = "foo"/>

:::details

<img :src= "$withBase( '/ALG-03/img_2.png' )" alt = "foo"/>

```java
	public class TreeNode {
		int val = 0;
		TreeNode left = null;
		TreeNode right = null;
	}
	public static int maxSum = Integer.MIN_VALUE;
	
	public static int test5(TreeNode root){
		if (root == null) {
			return 0;
		}
		
		// 获取左右节点的最大贡献值
		int leftGain = Math.max(test5(root.left), 0);
		int rightGain = Math.max(test5(root.right), 0);
		
		
		// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
		int priceNewPath = root.val + leftGain + rightGain;
		
		// 更新答案
		maxSum = Math.max(maxSum, priceNewPath);
		
		
		// 返回节点的最大贡献值
		return root.val + Math.max(leftGain, rightGain);
		
	}
```

:::



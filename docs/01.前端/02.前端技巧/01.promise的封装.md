---
title: promise的封装
date: 2022-05-01 09:51:37
permalink: /pages/8143cc480faf9a11/
categories:
  - 前端
  - 前端技巧  
tags:
  - JS
author: WJYGRIT
---

# Promise

> [代码仓库地址](https://github.com/GRITWJY/wjyFrontSkill/blob/master/js/promise.js)

## node.js风格函数的promise化

这里有两种方式，一种是我在网上找到的，另一种是《nodejs设计模式》中的

promisify 是把callback形式转成promise形式

### 简单场景：用JS加载图片的需求

```javascript
const imageSrc = 'https://www.themealdb.com/images/ingredients/Lime.png';

function loadImage(src, callback) {
	const image = document.createElement('img')
	image.src = src
	image.alt = "foo"
	image.style = 'width:200px;height:200px'
	image.onload = () => callback(null, image)
	image.onerror = () => callback(new Error("加载失败"))
	document.body.appendChild(image)
}

loadImage(imageSrc, function (err, content) {
	if (err) {
		console.log(err)
		return
	}
	console.log(content)
})
```

> promisify化

```javascript
const imageSrc = 'https://www.themealdb.com/images/ingredients/Lime.png';

function loadImage(src, callback) {
	const image = document.createElement('img')
	image.src = src
	image.alt = "foo"
	image.style = 'width:200px;height:200px'
	image.onload = () => callback(null, image)
	image.onerror = () => callback(new Error("加载失败"))
	document.body.appendChild(image)
}

const loadImagePromise = function (src) {
	return new Promise(function (resolve, reject) {
		loadImage(src, function (err, image) {
			if (err) {
				reject(err)
				return
			}
			resolve(image)
		})
	})
}

loadImagePromise(imageSrc).then(res => {
	console.log(res)
}).catch(err => {
	console.log(err)
})
```

> 封装

```javascript

const imageSrc = 'https://www.themealdb.com/images/ingredients/Lime.png';

function loadImage(src, callback) {
	const image = document.createElement('img')
	image.src = src
	image.alt = "foo"
	image.style = 'width:200px;height:200px'
	image.onload = () => callback(null, image)
	image.onerror = () => callback(new Error("加载失败"))
	document.body.appendChild(image)
}


function promisify(original) {

	function fn(...args) { // 参数，图片连接
		return new Promise(function (resolve, reject) {
			// 在这里添加回调
			args.push((err, ...values) => {
				if (err) {
					return reject(err)
				}
				resolve(values)
			})

			// original.apply(this,args)
			Reflect.apply(original, this, args)
		})
	}

	return fn
}

const loadImagePromise = promisify(loadImage)

async function load() {
	try {
		const res = await loadImagePromise(imageSrc)
		console.log(res)
	} catch (e) {
		console.log(e)
	}
}

load()

```

> node.js中的封装

```javascript
module.exports.promisify = function (original) {

	return function promisifyed() {
		// 获取参数
		const args = [].silce.call(arguments);

		return new Promise((resolve, reject) => {
			//[1]
			args.push((err, result) => {
				//[2]
				if (err) {
					return reject(err); //[3]
				}
				if (arguments.length <= 2) {
					resolve(result); //[4]
				} else {
					resolve([].slice.call(arguments, 1));
				}
			});
			original.apply(null, args); //[5]
		});
	};
};

```

该函数返回一个promisified()的函数，它代表输入中给出的original 的promise化的版本

- 1、 promisified函数使用Promise构造一个新的promise，并立即返回给调用者
- 2、 在传递给Promise构造函数的函数中，确保传递给original，一个特殊的回调函数。
- 3、 在特殊回调中，如果收到错误，立即拒绝该promise
- 4、 如果没有收到错误，则使用一个值或一个值数组解决promise，具体值的数量取决于传递给回调的结果数
- 5、 最后，简单的调用original,并带有已创建的arguments列表

## 有限制的并行执行

多个task，一次最多3个

```javascript
function task() {
	return new Promise(function (resolve, reject) {
		console.log('running')
		setTimeout(resolve(), Math.random() * 100)
	}).then(() => {
		console.log('done')
	})
}

class handleTask {
	constructor(maxCount) {
		this.maxCount = maxCount
		this.pendingTask = [] // 待执行的任务
		this.completed = 0
		this.count = 0
	}


	run(task) {
		if (this.count < this.maxCount) {
			this.count++
			task().then(() => {
				this.count--
				this.completed++
				if (this.pendingTask.length > 0) {
					this.run(this.pendingTask.shift())
				}
			})
		} else {
			this.pendingTask.push(task)
		}
	}
}


```

## promise源码【手写】

```javascript

class Promise {
	constructor(executor) {
		this.promiseState = 'pending'
		this.promiseRresult = null
		this.callbacks = []
		const sefl = this
    
		function resolve(data) {
			// 只改变一次
			if (this.promiseState === 'pending') {
				sefl.promiseState = 'fullfilled'
				self.promiseResult = data
				setTimeout(() => {
					self.callbacks.forEach(item => {
						item.onResolved(data)
					})
				})
			}
		}

		function reject(data) {
			// 只改变一次
			if (this.promiseState === 'pending') {
				sefl.promiseState = 'rejected'
				self.promiseResult = data
				setTimeout(() => {
					self.callbacks.forEach(item => {
						item.onRejected(data)
					})
				})
			}
		}

		try {
			executor(resolve, reject)
		} catch (e) {
			reject(e)
		}
	}


	then(onResolved, onRejected) {
		const self = this
		if (typeof onRejected !== 'function') {
			onRejected = reason => {
				throw reason
			}
		}
		if (typeof onResolved !== 'function') {
			onResolved = value => value
		}

		return new Promise((resolve, reject) => {
			function callback(type) {
				try {
					let result = type(self.promiseRresult)
					if (result instanceof Promise) {
						result.then(v => {
							resolve(v)
						}, r => {
							reject(r)
						})
					} else {
						resolve(result)
					}
				} catch (e) {
					reject(e)
				}
			}

			if (this.promiseState === 'fullfilled') {
				setTimeout(() => {
					callback(onResolved)
				})
			}


			if (this.promiseState === 'rejected') {
				setTimeout(() => {
					callback(onRejected)
				})
			}

			if (this.promiseState === 'pending') {
				this.callbacks.push({
					onRejected: function () {
						callback(onRejected)
					},
					onResolved: function () {
						callback(onResolved)
					}
				})
			}

		})
	}

	catch(onRejected) {
		return this.then(undefined, onRejected)
	}

	// this调用自身class方法
	static resolve(value) {
		return new Promise((resolve, reject) => {
			if (value instanceof Promise) {
				value.then(v => {
					resolve(v)
				}, r => {
					reject(r)
				})
			} else {
				resolve(value)
			}
		})
	}

	static reject(reason) {
		return new Promise((resolve, reject) => {
			reject(reason)
		})
	}

	static all(promises) {
		return new Promise((resolve, reject) => {
			let count = 0
			let arr = []
			for (let i = 0; i < promises.length; i++) {
				promises[i].then(v => {
					count++
					arr[i] = v
					if (count === promises.length) {
						resolve(arr)
					}
				}, r => {
					reject(r)
				})
			}
		})
	}

	static race(promises) {
		return new Promise((resolve, reject) => {
			let count = 0
			let arr = []
			for (let i = 0; i < promises.length; i++) {
				promises[i].then(v => {
					resolve(v)
				}, r => {
					reject(r)
				})
			}
		})
	}

}

```


---
title: 函数柯里化

date: 2022-05-27 14:43:34

permalink: /pages/4kfkzk2/

categories:
    - 前端
    - 前端技巧

tags:
    - JS 

author:
    name: WJYGRIT
    link: https://github.com/GRITWJY
---

# 函数柯里化

此文章已收录到[我自己的前端函数库,里面收集和整理了平时开发和学习中遇到过的所有功能函数](https://github.com/GRITWJY/wjyFrontSkill)


## 柯里化
```javascript
Function.prototype.curry = function () {
	let slice = Array.prototype.slice
	let defaultArgs = slice.call(arguments)
	let that = this
	return function () {
		return that.apply(this,
				// 类数组对象转为数组
				defaultArgs.concat(slice.call(arguments))
			)
	}
}

let data = [1,2,3,4,5]

data.sort((a,b)=>b-a)

Array.prototype.sortDescending = Array.prototype.sort.curry((a,b)=>b-a)

data.sortDescending()
```


## call/apply/bind
关于这三个函数的解释可以看这个连接，我就不写了 [JavaScript 中 call()、apply()、bind() 的用法](https://www.runoob.com/w3cnote/js-call-apply-bind.html)
```javascript
/*
*  call()
*    语法: call(fn,obj,...args)
*    功能: 执行fn, 使this为obj, 并将后面n个参数传给fn
*  1. 指定为null或undefined时,会自动替换为全局对象,原始值会被包装,
*  2. 返回调用者提供的this值,和参数调用该函数的返回值. 若该方法没有返回值,则返回undefined
* */
export function call(fn, obj, ...args) {
	// 如果obj 是undefined/null, this指定为window
	if (obj === undefined || obj === null) {
		obj = window
	}
	// 为obj添加临时方法
	obj.temp = fn

	// 通过obj来调用这个方法 ==> 也就会执行fn函数 ==> 此时fn中的this就是obj的
	const result = obj.temp(...args)

	// 删除临时方法
	delete obj.temp
	return result
}

/*
* apply()
*  语法 : apply(fn,obj,args)
*   特性: args是一个数组,而不是一个一个参数
* 改变函数this指向
* */
export function apply(fn, obj, args) {
	if (obj === undefined || obj === null) {
		obj = window;
	}
	obj.temp = fn;
	const result = obj.temp(...args);
	delete obj.temp;
	return result;
}


/*
* bind()
*   语法
*   给fn绑定this为obj, 并指定参数为后面n个参数,不执行
* */
export function bind(Fn, obj, ...args) {
	// 接收参数
	return function (...args2) {
		return call(Fn, obj, ...args, ...args2)
	}
}

```


## myInstanceof

```javascript
/**
 * myInstanceOf(obj,Type)
 * 检查obj是否是type的实例
 * type的显示原型对象是否是obj的原型链上的某个对象， 如果是则返回true
 * */

export function myInstanceof(obj, Fn) {
	let prototype = Fn.prototype
	let proto = obj.__proto__
	while (proto) {
		if (prototype === proto) {
			return treu
		}
		proto = proto.__proto__
	}
	return false
}
```
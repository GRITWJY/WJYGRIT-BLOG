---
title: 前端基础巩固2
date: 2022-07-10 16:12:34  
permalink: /pages/KE2930S/  
categories:
    - 前端
    - 前端技巧
tags:
    - 基础
author:  
    name: WJYGRIT   
    link: https://github.com/GRITWJY  
---

# 前端基础巩固2


## 1. JS有哪些数据类型以及它们的区别?

- 基本数据类型: `string/number/null/boolean/undefined/symbol`
- 引用数据类型: `object/function`

区别

- 1. 声明变量时的存储分配
    - 基本数据类型存储在栈中: 大小固定
    - 引用数据类型存储在堆中: 大小不固定,动态分配

- 2. 不同的内存分配机制也有不同的访问机制
    
    不可以直接访问堆内存空间的位置, 以及不可以直接操作堆内存空间,只能操作对象在栈内存中的引用地址, 基本数据类型可以从栈中直接访问
    
- 3. 赋值变量时的不同
    - 基本数据类型: 将原始的值赋值给新的变量
    - 引用数据类型: 将引用地址赋值给新的变量

## 2. JS基本数据类型中的null和undefined的区别以及应用?

`null` 表示"没有对象", 该处不应该有值

`undefined` 表示"缺少值", 即该处应该有一个值, 但是还没有定义

转为数值也不同, `null` 转为数值为0, `undefined` 转为数值为 `NaN`

**什么时候会有null?**

- 1. 对象原型链的终点
    
- 2. 在js的DOM元素获取中，如果没有获取到指定的元素对象，结果一般是null

**什么时候会出现undefined?**

- 1. 变量声明了,但没有赋值

- 2. 调用函数时, 应该提供的参数没有提供, 该参数就等于`undefined`

- 3. 对象有没有赋值的属性, 该属性值为 `undefined`
   
- 4. 函数没有返回值时, 默认返回 `undefined` 
    
## 3. JS数据类型检测的方式有哪些?

- `typeof (检测数据类型的运算符)`
```javascript
console.log("数值",typeof 10);
console.log("布尔",typeof true);
console.log("字符串",typeof "faf");
console.log("数组", typeof []);
console.log("函数", typeof function(){});
console.log("对象", typeof {});
console.log("undefined", typeof undefined);
console.log("null", typeof null);

// 数值 number
// 布尔 boolean
// 字符串 string
// 数组 object
// 函数 function
// 对象 object
// undefined undefined
// null object
```

**为什么 `typeof null` 是object?**

- `typeof null` 的结果为`Object`的原因是一个`bug`, 在JS的最初版本中, 使用的32位系统, JS为了性能优化, 使用地位来存储变量的类型信息.

|数据类型|机器码标识|
|----|----|
|对象|000 |
|整数|1|
|浮点数|010|
|字符串|100|
|布尔|110|
|undefined|-2^31,全为1|
|null|全为0|

在判断数据类型时, 是根据机器码地位标识来判断的, 而 `null` 的机器码标识全为0, 而对象的机器码地位标识为`000`, 所以 `typeof null` 的结果被误判为 `Object`

- **`instanceof`检测某一个实例是否属于这个类**

可以判断对象的类型, 内部运行机制: 判断它在原型链上能否找到这个类型的原型

- **`constructor`检测实例和类的关系,引用原来构造该对象的函数**
```javascript
console.log("数值", (10).constructor === Number);
console.log("字符串",("你好").constructor === String);
console.log("布尔",(true).constructor === Boolean)
console.log("数组",([]).constructor === Array);
console.log("函数",(function () {}).constructor === Function);
console.log("对象",({}).constructor === Object);
```


- **`Object.prototype.toString.call()`**

数组函数都是作为Object的实例, 会重写`toString`方法, 不同对象会根据原型链调用重写之后的方法, 而不是`Object`上的

```javascript
var a = Object.prototype.toString;
console.log("数值",a.call(10));
console.log("布尔",a.call(true));
console.log("字符串",a.call("fffas"));
console.log("数组",a.call([]));
console.log("函数",a.call(function (){}));
console.log("对象",a.call({}));
console.log("undefined",a.call(undefined));
console.log("null",a.call(null));
```

## 4. JS中instanceof操作符的实现原理以及实现?

`instanceof 操作符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置`


## 5. JS中typeof NaN 的结果是什么?

## 6. JS中判断数组的方法?

## 7. JS中 + 操作符什么时候用于字符串拼接?

## 8. JS中Object.is() 和 ===, == 的区别?

## 9. JS中如何进行隐式转换?

## 10. JS中深拷贝和浅拷贝的区别?

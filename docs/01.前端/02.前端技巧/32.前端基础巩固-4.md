---
title: 前端基础巩固4  
date: 2022-07-13 19:50:34  
permalink: /pages/CHEWO/  
categories:
    - 前端
    - 前端技巧
tags:
    - 基础
    - js
author:  
    name: WJYGRIT   
    link: https://github.com/GRITWJY  
---

# 前端基础巩固4

## 1. ES6中 forof 和 forin 的区别
:::details 解析

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下

- `for...of `遍历获取的是对象的键值，`for...in` 获取的是对象的链名
- `for...in` 会遍历对象的整个原型链，性能非常差不推荐使用，而 `for...of` 之遍历当前对象，不会遍历原型链
- 对于数组的遍历，`for...in` 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),`for...of` 值返回数组的下标对应的属性值

总结 ：`for...in`循环主要是为了遍历对象而生，不适用于遍历数组；`for...of` 循环可以用来遍历数组、类数组对象，字符串、set/map
:::
## 2. JS中判断一个属性是属于实例对象还是集成于构造函数
:::details 解析

`hasOwnProperty()` 检测一个属性是否属于自身对象, 还是继承于原型链上的.

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sex = "nan"
var p =new Person('张三',19)
p.phone = 12345
p.height = 180
console.log(p)

console.log(p.hasOwnProperty('phone')) // true
console.log(p.hasOwnProperty('sex')) // false

for(let i in p) {
    if (p.hasOwnProperty(i)) { // 没有sex, 它在原型链上, 不是实例对象
        console.log(i, p[i])
    }
}
```
:::


## 3. ES6中使用 Promise 封装 ajax
:::details 解析

```javascript
function getJSON(url) {
    return new Promise((resolve, reject)=> { 
        // 创建一个实例对象
        let xhr = new XMLHttpRequest();
        // 新建一个http请求
        xhr.open('GET', url, true)
        // 发送请求
        xhr.send(null)
        // 设置状态监听函数
        xhr.onreadystatechange = function (ev) { 
            if (xhr.readyState !== 4) return
            // 当前请求成功或者失败
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.response) // 请求结果
            } else {
                reject(new Error(this.statusText))
            }
        }
        
        // 设置错误的监听函数
        xhr.onerror = function () {
            reject(new Error(xhr.statusText))
        }
        // 设置响应的数据类型
        xhr.responseType="json"
        //......
    })
}3
```
:::

## 4. JS 中 'use strict' 是什么意思? 使用它的区别在哪
:::details 解析

使用严格模式, 不会支持一些不规范的语法
- 1. 使调试更加容易
    
- 2. 变量在赋值之间是必须要声明的, 防止意外的全局变量
    
- 3. 取消 this 值的强制转换
    
- 4. 不允许函数参数重名
     
:::

## 5. JS中如何实现继承
:::details 解析

`B(子类) --> A(父类)`, 继承可以让子类具有父类的各种属性和方法
- 原型链继承: 子类的实例对象使用的是同一个
```javascript
function Person() {
    this.name = "Person"
    this.arr = [1,2,3,4]
}
function Child() {
    this.type = 'child'
}

Child.prototype = new Person()
var c1 = new Child()
var c2 = new Child()
c1.arr.push(5)
console.log(c1)
console.log(c2)
// 修改原型上的值时, 所有实例都会改变
```

- 构造函数继承: 不能继承原型属性上的方法和属性
```javascript
function Person() {
    this.name = "Person"
    this.arr = [1,2,3,4]
}

Person.prototype.age = 18 // 没有这个age

function Child() {
    Person.call(this) // 将Person里的内容放到Child里
    this.type = "child"
}

c1.arr.push(5) // 不会互相影响
console.log(c1)
console.log(c2)
```

- 组合继承:
```javascript
function Person() {
    this.name = "Person"
    this.arr = [1,2,3,4]
}
Person.prototype.age = 18
function Child() {
    Person.call(this)
    this.type = "child"
}
Child.prototype = new Person();
Child.prototype.constructor = Child
var c1 = new Child()
var c2 = new Child()
c1.arr.push(5) // 不会互相影响

console.log(c1.constructor)

console.log(c1)
console.log(c2)

```
:::

## 6. vue的生命周期
:::details 解析

<img :src="$withBase('/img/CHEWO/img.png')" alt="foo"/>

- `beforeCreate` ：初始化了部分参数，如果有相同的参数，做了参数合并，执行 `beforeCreate` ；
- `created` ：初始化了 `Inject 、Provide 、 props 、methods 、data 、computed` 和 `watch`，执行 `created` ；
- `beforeMount` ：检查是否存在 el 属性，存在的话进行渲染 dom 操作，执行 beforeMount ；
- `mounted` ：实例化 `Watcher` ，渲染 dom，执行 `mounted` ；
- `beforeUpdate` ：在渲染 `dom` 后，执行了 `mounted` 钩子后，在数据更新的时候，执行 `beforeUpdate` ；
- `updated` ：检查当前的 `watcher` 列表中，是否存在当前要更新数据的 `watcher` ，如果存在就执行 `updated` ；
- `beforeDestroy` ：检查是否已经被卸载，如果已经被卸载，就直接 `return` 出去，否则执行 `beforeDestroy` ；
- `destroyed` ：把所有有关自己痕迹的地方，都给删除掉；

:::

## 7. vue 中 watch 如何对对象进行深监听
:::details 解析

```
props:['pageData'],
data(){
    return{
       
    }
},
watch:{
   pageData:{
       handler: function (newval, oldVal) {
            console.log(newval)
        },
        deep: true
   }
}  
        
        
        
watch: {
    "object.name": {
        handler(newName, oldName) {
           console.log("object.name变化了 ")
        },
        deep: true
    }
}

```
:::

## 8. vue 中 $nextTick

:::details 解析

将回调函数延迟在下一次DOM更新数据之后调用

- Vue是异步更新的，只要侦听到数据发生变化，vue将开启一个队列，并缓冲同一个事件循环中发生的所有数据的变化，最后再统一更新视图，这是为了避免不必要的计算和DOM操作
  
- 异步更新机制的核心是利用了浏览器的异步任务队列来实现。Vue 在内部对异步队列尝试使用原生的 `Promise.then、MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替
  
- 当多次更新数据，调用update时，先将watcher缓存起来，放在一个队列中。也就是调用了 `queueWatcher`，执行`queue.push(watcher)`。然后通过 `flushSchedulerQueue` 方法统一处理需要更新的 watcher
  
- 通过 `nextTick` 方法 将 `flushSchedulerQueue` 放入一个 callbacks 数组，在一个事件循环处理所有的回调
:::
## 9. 父子组件的访问方式
:::details 解析

- 通过 `$children` 访问子组件的数据, 包含了所有的子组件对象(比较少用, 常用的是通过$ref)

- 通过 `$parent` 获取父组件数据 (注: 子组件避免直接访问父组件数据, 耦合度太高)


- 通过 `prop`, 向子组件传递数据

- 通过自定义事件向父组件传递数据

- `provide/inject` 块级通信, provide 可以在祖先组件中指定我们想要提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法。
    - Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。
    - provide/inject 中变量的修改是无法控制的，换句话说，你不知道是哪个组件修改了这个全局状态

:::    

## 10. 项目优化过程[总结]


## 11. cdn为什么能加速

## 12. 如何用 rem ，vm做移动端适配

## 13. 项目如何解决跨域

## 14. jsonp如何实现

## 15. 自定义指令

## 16. https的加密过程

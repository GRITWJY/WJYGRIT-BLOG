---
title: 前端面经
date: 2022-06-08 23:35:34
permalink: /pages/KSOWKS/
categories:
  - 前端
  - 前端技巧
tags:
  - 面试
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 前端面经

## 1. 什么是事件代理（事件委托） 有什么好处

**事件委托的原理：** 不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。

**优点：**
- **减少内存消耗和 dom 操作，提高性能** 
  
在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，**因为需要不断的操作 dom,那么引起浏览器重绘和回流的可能也就越多，页面交互的事件也就变的越长，这也就是为什么要减少 dom 操作的原因。每一个事件处理函数，都是一个对象，多一个事件处理函数，内存中就会被多占用一部分空间。** 如果要用事件委托，就会将所有的操作放到 js 程序里面，只对它的父级进行操作，与 dom 的操作就只需要交互一次，这样就能大大的减少与 dom 的交互次数，提高性能；

- **动态绑定事件** 因为事件绑定在父级元素 所以新增的元素也能触发同样的事件


## 2. addEventListener 默认是捕获还是冒泡

默认是冒泡

addEventListener第三个参数默认为 false 代表执行事件冒泡行为。

当为 true 时执行事件捕获行为。

## 3. webpack Plugin 和 Loader 的区别
- Loader

用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 build 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。

- plugin

目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

## 4. css 优先级是怎么计算的

- 第一优先级：!important 会覆盖页面内任何位置的元素样式
- 1.内联样式，如 style="color: green"，权值为 1000
- 2.ID 选择器，如#app，权值为 0100
- 3.类、伪类、属性选择器，如.foo, :first-child, div[class="foo"]，权值为 0010
- 4.标签、伪元素选择器，如 div::first-line，权值为 0001
- 5.通配符、子类选择器、兄弟选择器，如*, >, +，权值为 0000
- 6.继承的样式没有权值


## [5. http相关](https://www.wjygrit.cn/pages/aFADFAFA61298/#http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB)

## 6. position 有哪些值，作用分别是什么
- absolute
  
    生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。如果它的 父容器设置了 position 属性，并且 position 的属性值为 absolute 或者 relative，那么就会依据父容器进行偏移
  
- fixed （老IE不支持）
  
    生成绝对定位的元素，相对于浏览器窗口进行定位。属性的元素在标准流中不占位置
  
- relative
  
    生成相对定位的元素，相对于其正常位置进行定位。相对自身进行偏移
  
- static
  
    默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
  
-  inherit
   
    规定从父元素继承 position 属性的值。

## [7. 垂直水平居中](https://juejin.cn/post/6844903982960214029#heading-21)

## 8.vue 组件通讯方式有哪些方法

- props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的

- $parent,$children 获取当前组件的父组件和当前组件的子组件

- $attrs 和$listeners A->B->C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题

- 父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)

- $refs 获取组件实例

- envetBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式

- vuex 状态管理


## 9.路由原理 history 和 hash 两种路由方式的特点

**hash模式**

- 1. location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

- 2. 可以为 hash 的改变添加监听事件 `window.addEventListener("hashchange", funcRef, false);`
  
- 3. 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了


**history模式**
利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

## 10. flex:1 是哪些属性组成的


## 11. vue-router 中路由方法 pushState 和 replaceState 能否触发 popSate 事件

## 12. babel 是什么，原理了解吗

## 13. RAF 和 RIC 是什么




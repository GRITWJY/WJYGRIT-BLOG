---
title: 浏览器渲染部分工作原理
date: 2022-06-05 00:26:34
permalink: /pages/ABCMEL/
categories:
  - 前端
  - 前端基础概念
tags:
  - 浏览器
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 浏览器渲染部分工作原理
此部分可以说是浏览器中比较重要的地方了吧，这里我的文章组织结构如下
[[toc]]

## DOM树构建

### HTML 解析器
#### `问题1` HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？

区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。

 
#### `问题2` 解析器输出的解析树是怎么组成的? 
  
解析器的输出“解析树”是由 `DOM 元素和属性节点构成的树结构`。DOM 是文档对象模型 `(Document Object Model)` 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。
`解析树的根节点是“Document”对象。` [DOM的定义](www.w3.org/DOM/DOMTR)


#### `问题3` HTML 无法用常规的自上而下或自下而上的解析器进行解析?

原因有以下几点
- 1. 语言的宽容本质
- 2. 浏览器历来对一些常见的无效 HTML 用法采取包容态度。
- 3. 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容
  
#### `问题4` 讲讲浏览器解析HTML的算法

这里更详细的可以看[HTML5 规范详细地描述了解析算法](https://html.spec.whatwg.org/multipage/parsing.html), 这里我就只简单概括下

算法由两个阶段组成 `标记化和树构建`

> 标记化

`标记化` **是词法分析过程, 将输入内容解析成多个标记.** HTML标记包括起始标记/结束标记/属性名称和属性值

标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。

<img :src="$withBase('/ABCMEL/img.png')" alt='foo'/>


**标记化算法**
该算法的`输出结果是 HTML 标记`。该算法使用`状态机`来表示。`每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态`。`当前的标记化状态和树结构状态会影响进入下一状态的决定`。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。

关于状态机的这个概念, 可以看[力扣上8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)的例子

> 树构建

**树构建算法**

在创建解析器的同时，也会创建 Document 对象。`在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。`标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。`这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。`其算法`也可以用状态机来描述。这些状态称为“插入模式”。`

```html
<html>
  <body>
    Hello world
  </body>
</html>
```
`树构建阶段的输入是一个来自标记化阶段的标记序列`。
- 第一个模式是 **“initial mode”** 。接收 HTML 标记后转为 **“before html”模式** ，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。

- 然后状态将改为 **“before head”** 。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。

- 现在我们进入了 **“in head”模式**，然后转入 **“after head”模式** 。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为 **“in body”**。

- 现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。

- 接收 body 结束标记会触发 **“after body”模式**。现在我们将接收 HTML 结束标记，然后进入 **“after after body”** 模式。接收到文件结束标记后，解析过程就此结束。


<img :src="$withBase('/ABCMEL/img_1.png')" alt='foo'/>

#### 问题5 简单说下浏览器的容错机制
WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。
> 解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。
> 
> 遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。
> 
> 我们至少要能够处理以下错误情况：
> 
> - 1. 明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。
> - 2. 我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。
> - 3. 向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。
> - 4. 如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。


- `使用了</br>而不是<br>`

  有些网站使用了 `</br>` 而不是 `<br>`。为了与 IE 和 Firefox 兼容，WebKit 将其与 <br> 做同样的处理。
  
  ```
  if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
       reportError(MalformedBRError);
       t->beginTag = true;
  }
  ```

- 离散表格
  
  离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。

  ```javascript
  <table>
      <table>
          <tr><td>inner table</td></tr>
      </table>
      <tr><td>outer table</td></tr>
  </table>
  ```
  
  WebKit 会将其层次结构更改为两个同级表格：
  ```javascript
  <table>
      <tr><td>outer table</td></tr>
  </table>
  <table>
      <tr><td>inner table</td></tr>
  </table>
  ```
  
  代码如下：
  ```javascript
  if (m_inStrayTableContent && localName == tableTag)
          popBlock(tableTag);
  ```
  
  WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。

- 嵌套的表单元素
 
  如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。
 
  代码如下：

  ```
  if (!m_currentFormElement) {
    m_currentFormElement = new HTMLFormElement(formTag,    m_document);
  }
  ```


### CSS 解析
[CSS 规范定义了 CSS 的词法和语法。](https://www.w3.org/TR/CSS2/grammar.html)

词法语法（词汇）是针对各个标记用正则表达式定义的：

```
comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/
num   [0-9]+|[0-9]*"."[0-9]+
nonascii  [\200-\377]
nmstart   [_a-z]|{nonascii}|{escape}
nmchar    [_a-z0-9-]|{nonascii}|{escape}
name    {nmchar}+
ident   {nmstart}{nmchar}*
```


语法是采用 BNF 格式描述的。

```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : '.' IDENT
  ;
element_name
  : IDENT | '*'
  ;
attrib
  : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] ']'
  ;
pseudo
  : ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
  ;
```

解释：这是一个规则集的结构：
```css
div.error , a.error {
  color:red;
  font-weight:bold;
}
```

div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：
```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
```
这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。





### 处理脚本和样式表的顺序


#### 脚本
  - 网络的模型是同步的。网页作者希望解析器遇到 `<script>` 标记时立即解析并执行脚本。`文档的解析将停止，直到脚本执行完毕。`
  
  - 如果脚本是外部的，那么`解析过程会停止，直到从网络同步抓取资源完成后再继续`。
  
  - 作者也可以将脚本标注为`“defer”`，这样它就不会停止文档解析，**而是等到解析结束才执行**。HTML5 增加了一个选项`async`，**可将脚本标记为异步，以便由其他线程解析和执行**。

#### 预解析

WebKit 和 Firefox 都进行了这项优化。`在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。`请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；`预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用`。


#### 样式表
另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，`就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。`这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

## 呈现树构建

在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。`这是由可视化元素按照其显示顺序而组成的树`，也是文档的可视化表示。它的作用是让您`按照正确的顺序绘制内容`。

### 呈现树和 DOM 树的关系
呈现器是和 DOM 元素相对应的，但并非一一对应。`非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。`

`有一些 DOM 元素对应多个可视化对象。`它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。

`有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。`浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。


### 样式计算难点
构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。

样式计算存在以下难点：
- 1. 样式数据是一个超大的结构，存储了无数的样式属性，这可能造成`内存问题。`
  
- 2. 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。`选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。`

- 3. 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。

让我们来看看浏览器是如何处理这些问题的：

#### 共享样式数据
WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：

- 1. 这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）
- 2. 任何元素都没有 ID
- 3. 标记名称应匹配
- 4. 类属性应匹配
- 5. 映射属性的集合必须是完全相同的
- 6. 链接状态必须匹配
- 7. 焦点状态必须匹配
- 8. 任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配
- 9. 元素中不能有任何 inline 样式属性
- 10.不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。


#### FireFox 规则树
  结构划分
  
  使用规则树计算样式上下文
#### 对规则进行处理以简化匹配
#### 以正确的层叠顺序应用规则

### 渐进式处理

## 布局

## 绘制

## 动态变化

## 时间循环

## 合成

## 分层

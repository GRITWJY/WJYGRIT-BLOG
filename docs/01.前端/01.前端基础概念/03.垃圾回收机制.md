---
title: V8 垃圾收集机制
date: 2022-05-26 13:56:37
permalink: /pages/4orgjeo/
categories:
    - 前端
    - 前端基础概念
tags:
    - JS

author:
    name: WJYGRIT
    link: https://github.com/GRITWJY
---

# V8 垃圾收集机制

参考资料
- [赠你13张图，助你20分钟打败了「V8垃圾回收机制」！！！](https://mp.weixin.qq.com/s?__biz=Mzg2NjY2NTcyNg==&mid=2247483683&idx=1&sn=973b0280aa9c6eb1678ea530ee4d2381&chksm=ce4614b2f9319da402278b86e63f44e818e832ecbaafdada344ba979de3df4443a8ed53b0cb1&scene=21#wechat_redirect)
- [v8-perf](https://github.com/thlorenz/v8-perf/blob/master/gc.md#two-generations)
- [Memory Management Reference](https://www.memorymanagement.org/index.html)
- [V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)
- [A tour of V8: Garbage Collection](https://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)
- [v8.dev](https://v8.dev/docs)


注意事项：

- 本篇文章参考了大量的资料，但主要以英文版的资料为主，文章结构 90% 是按照这一篇文章组织的，但其中会加一些其他博客中的理解和知识点。有能力的读者可以看英文原版的，所有相关连接都在上面了。

- 鉴于 只给出概念 可能比较枯燥， 我就以问答的形式展示， 将每个部分的知识点以问题划分。

- 本篇中的一些翻译可能不是准确、顺口，这个之后会继续改进。


`stop-the-world`: 在垃圾收集中经常涉及到对对象的挪动，进而导致需要对对象引用进行更新。
为了保证引用更新的正确性，将会暂停其他的线程的情况。

## 目标和技术
### 问题1 ： V8垃圾收集的目标是什么？
    - 确保快速的对象分配、减少垃圾收集停顿和减少内存碎片
### 问题2 ： V8垃圾收集用到了哪些技术点 ？
    - `stop-the-world`, [世代的精确垃圾收集](https://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection)
    - 执行只能同步运行的新生代垃圾收集周期时，停止程序运行
    - 许多步骤并行执行，在大多数垃圾收集周期中只处理部分对象堆，以将对主线程执行的影响降至最低
    - `标记紧凑 mark compact` 是以增量的方式执行，因此不会 `stop-the-world`
    - 将对象包裹在句柄中，以便跟踪内存中的对象，即使它们被移动。 (简述就是： 跟中内存中的对象)
    - 识别内存死区
    - CG 能够快速扫描已标记过的单词
    - follows pointers and ignores Smis and data only types like strings

## 内存花费
- 分配内存花费低
- 内存池耗尽时收集成本高昂

## 如何辨别需要回收的内存？
垃圾收集器要解决的最基本问题就是，辨别需要回收的内存。

### **问题3 ： 如何辨别需要回收的内存？**

如果一个对象可由某个活跃对象通过指针链访问到，则它就是活跃的，其他的视为垃圾。
  
这里给出了几个方法
- 1、 如果无法从根节点访问对象，而根节点或另一个活动对象未引用该对象时，则认为该对象 dead
- 2、 全局跟对象被视为根对象
- 3、 被局部变量锁执行的对象属于跟底下，因为他们的栈被视为根对象
- 4、 浏览器对象，如DOM元素，也属于根对象，尽管在某些场合下它们只是弱引用。


### **问题4 ： V8如何区分堆中的指针和数据？**

垃圾回收器面临的第一个问题是，如何才能在堆中区分指针和数据，因为指针指向着活跃的对象。大多数垃圾回收算法会将对象在内存中挪动（以便减少内存碎片，使内存紧凑），因此即使不区分指针和数据，我们也常常需要对指针进行改写。

目前主要有三种方法来识别指针：

- 保守法：这种方法对于缺少编译器支持的情况非常必要。大体上，我们将所有堆上对齐的字都认为是指针，这就意味着有些数据也会被误认为是指针。于是某些实际是数字的假指针，会被误认为指向活跃的对象，则我们会时常出现一些奇异的内存泄漏。（译注：因为垃圾回收器会以为死对象仍然还有指针指向，错将死对象误认为活跃对象）而且我们也不能移动任何内存区域，因为这很可能会导致数据遭到破坏。这样，我们便无法通过紧凑内存来获得任何好处（比如更容易的内存分配、更少的内存访问、更有效的内存局部性缓存）。C/C++的垃圾回收器扩展会采用这种方式，比如Boehm-Demers-Weiser。
译注：如果内存是紧凑的，则内存分配时可以更容易分配较大片的内存，而无需因内存碎片而不断查找；同时，由于已分配的内存是连续或近似连续的，而Cahce所能缓存的内存有限，如果内存被Cache缓存起来，无需频繁地迫使Cache更换缓存的内存。C/C++由于指针算术的存在，编译器无法确定哪些内存是真正的垃圾，因而无法给垃圾回收器有效的提示，进而导致垃圾回收器不得不采取这样的保守策略。

- 编译器提示法：如果我们和静态语言打交道，则编译器能够准确地告诉我们每个类当中指针的具体位置。而一旦我们知道对象是哪个类实例化得到的，我们就能知道对象中所有的指针。JVM选择了这样的方法来进行垃圾回收。可惜，这种方法对于JS这样的动态语言来说不太好使，因为JS中对象的任何属性既可能是指针，也可能是数据。

- 标记指针法：这种方法需要在每个字的末位预留一位来标记这个字代表的是指针抑或数据。这种方法需要一定的编译器支持，但实现简单，而且性能不俗。V8采用的就是这种方法。某些静态语言也采用了这样的方法，如OCaml。

V8将所有属于-230…230-1范围内的小整数（V8内部称其为Smis）以32bit字宽来存储，其中的最低一位保持为0，而指针的最低两位则为01。由于对象以4字节对齐，因此这样表达指针没有任何问题。大多数对象所含有的只是一组标记后的字，因此垃圾回收可以进行的很快。而有些类型的对象，比如字符串，我们确定它只含有数据，因此无需标记。

## 分代回收
### **问题5 ： 为什么分代回收？**

在 JS 中， 对象存活周期分为两种情况
- 存活周期很短： 经过一次垃圾回收后， 就被释放回收掉
- 存活周期很长： 经过多次垃圾回收后， 依然存在

那么针对这些存活周期长的，若我们开一个空间专门存储，然后直到空间满了后再进行清理， 这样就可以减少性能消耗

对于这个问题，V8做了分代回收的优化方法，通俗点说就是：V8将堆分为两个空间，一个叫新生代，一个叫老生代，新生代是存放存活周期短对象的地方，老生代是存放存活周期长对象的地方
-  新生代由 `新生区`组成，大多数对象被分配在这里。
-  老生代 被分为多个部分： 有 老生数据区、 老生指针区、 大对虾区
-  旧空间存储的对象经过了足够的GC循环，可以升级到旧一代

## V8 的 堆组织
### **问题6 ： V8怎么组织的堆?**
- **新生代** ：大多数对象被分配在这里。新生区是一个很小的区域，在1~8MB之间， 垃圾回收在这个区域非常频繁，与其他区域相独立。
- **老生指针区** ：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。
- **老生数据区** ：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。
- **大对象区** ：这里存放体积超越其他区大小的对象。每个对象有自己mmap产生的内存。垃圾回收器从不移动大对象。
- **代码区** ：代码对象，也就是包含JIT之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。
- **Cell区、属性Cell区、Map** ：这些区域存放Cell、属性Cell和Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。

每个区域都由一组内存页构成。内存页是一块连续的内存，经mmap（或者Windows的什么等价物）由操作系统分配而来。除大对象区的内存页较大之外，每个区的内存页都是1MB大小，且按1MB内存对齐。除了存储对象，内存页还含有一个页头（包含一些元数据和标识信息）以及一个位图区（用以标记哪些对象是活跃的）。另外，每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。这就是一套经典配置方案，其他的方案我们稍后讨论。

## 新生代
`Scavenge算法`
在JavaScript中，任何对象的声明分配到的内存，将会先被放置在新生代中，而因为大部分对象在内存中存活的周期很短，所以需要一个效率非常高的算法。在新生代中，主要使用Scavenge算法进行垃圾回收，Scavenge算法是一个典型的牺牲空间换取时间的复制算法，在占用空间不大的场景上非常适用。

Scavange算法将新生代堆分为两部分，分别叫from-space和to-space，工作方式也很简单，就是将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用。

### **问题7 ： 新生代步骤**

具体步骤为以下4步：
- 1、标记活动对象和非活动对象
- 2、复制from-space的活动对象到to-space中并进行排序
- 3、清除from-space中的非活动对象
- 4、将from-space和to-space进行角色互换，以便下一次的Scavenge算法垃圾回收

### **问题8 ： 新生代中的对象什么时候变成老生代的对象？**

在新生代中，还进一步进行了细分。分为nursery子代和intermediate子代两个区域，一个对象第一次分配内存时会被分配到新生代中的nursery子代，如果经过下一次垃圾回收这个对象还存在新生代中，这时候我们将此对象移动到intermediate子代，在经过下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升
  
  
### **问题9 ： 如果新生区中某个对象，只有一个指向它的指针，而这个指针恰好是在老生区的对象当中，我们如何才能知道新生区中那个对象是活跃的呢？**

**写屏障**

为了解决这个问题，实际上在写缓冲区中有一个列表，列表中记录了所有老生区对象指向新生区的情况。新对象诞生的时候，并不会有指向它的指针，而当有老生区中的对象出现指向新生区对象的指针时，我们便记录下来这样的跨区指向。由于这种记录行为总是发生在写操作时，它被称为写屏障——因为每个写操作都要经历这样一关。

你可能好奇，如果每次进行写操作都要经过写屏障，岂不是会多出大量的代码么？没错，这就是我们这种垃圾回收机制的代价之一。但情况没你想象的那么严重，写操作毕竟比读操作要少。某些垃圾回收算法（不是V8的）会采用读屏障，而这需要硬件来辅助才能保证一个较低的消耗。V8也有一些优化来降低写屏障带来的消耗：

大多数的脚本执行时间都是发生在Crankshaft当中的，而Crankshaft常常能静态地判断出某个对象是否处于新生区。对于指向这些对象的写操作，可以无需写屏障。

Crankshaft中新出现了一种优化，即在对象不存在指向它的非局部引用时，该对象会被分配在栈上。而一个栈上对象的相关写操作显然无需写屏障。（译注：新生区和老生区在堆上。）

“老→新”这样的情况相对较为少见，因此通过将“新→新”和“老→老”两种常见情况的代码做优化，可以相对提升多数情形下的性能。每个页都以1MB对齐，因此给定一个对象的内存地址，通过将低20bit滤除来快速定位其所在的页；而页头有相关的标识来表明其属于新生区还是老生区，因此通过判断两个对象所属的区域，也可以快速确定是否是“老→新”。

一旦我们找到“老→新”的指针，我们就可以将其记录在写缓冲区的末端。经过一定的时间（写缓冲区满的时候），我们将其排序，合并相同的项目，然后再除去已经不符合“老→新”这一情形的指针。（译注：这样指针的数目就会减少，写屏障的时间相应也会缩短）

## 老生代

新生代空间的对象，身经百战之后，留下来的老对象，成功晋升到了老生代空间里，由于这些对象都是经过多次回收过程但是没有被回收走的，都是一群生命力顽强，存活率高的对象，所以老生代里，回收算法不宜使用Scavenge算法，为啥呢，有以下原因：

Scavenge算法是复制算法，反复复制这些存活率高的对象，没什么意义，效率极低

Scavenge算法是以空间换时间的算法，老生代是内存很大的空间，如果使用Scavenge算法，空间资源非常浪费，得不偿失啊。。

所以老生代里使用了Mark-Sweep算法(标记清理)和Mark-Compact算法(标记整理)

### **Mark-Sweep(标记清理)**

Mark-Sweep分为两个阶段，标记和清理阶段，之前的Scavenge算法也有标记和清理，但是Mark-Sweep算法跟Scavenge算法的区别是，后者需要复制后再清理，前者不需要，Mark-Sweep直接标记活动对象和非活动对象之后，就直接执行清理了。

- 标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记
- 清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象


### Mark-Compact(标记整理)

Mark-Sweep算法执行垃圾回收之后，留下了很多零零散散的空位，这有什么坏处呢？如果此时进来了一个大对象，需要对此对象分配一个大内存，先从零零散散的空位中找位置，找了一圈，发现没有适合自己大小的空位，只好拼在了最后，这个寻找空位的过程是耗性能的，这也是Mark-Sweep算法的一个缺点

这个时候Mark-Compact算法出现了，他是Mark-Sweep算法的加强版，在Mark-Sweep算法的基础上，加上了整理阶段，每次清理完非活动对象，就会把剩下的活动对象，整理到内存的一侧，整理完成后，直接回收掉边界上的内存

## Orinoco 优化
orinoco为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，它提出了增量标记、懒性清理、并发、并行的优化方法。


### 增量标记
你应该想到了，当一个堆很大而且有很多活跃对象时，标记-清除和标记-紧缩算法会执行的很慢。起初我研究V8时，垃圾回收所引发的500-1000毫秒的停顿并不少见。

增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用，启用之后每当一定量的内存分配后，脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样，增量标记也是一个深度优先搜索，并同样采用白灰黑机制来分类对象。


但增量标记和普通标记不同的是，对象的图谱关系可能发生变化！我们需要特别注意的是，那些从黑对象指向白对象的新指针。回忆一下，黑对象表示其已完全被垃圾回收器扫描，并不会再进行二次扫描。因此如果有“黑→白”这样的指针出现，我们就有可能将那个白对象漏掉，错当死对象处理掉。（译注：标记过程结束后剩余的白对象都被认为是死对象。）于是我们不得不再度启用写屏障。现在写屏障不仅记录“老→新”指针，同时还要记录“黑→白”指针。一旦发现这样的指针，黑对象会被重新染色为灰对象，重新放回到双端队列中。当算法将该对象取出时，其包含的指针会被重新扫描，这样活跃的白对象就不会漏掉。

### 惰性清理

增量标记完成后，惰性清理就开始了。所有的对象已被处理，因此非死即活，堆上多少空间可以变为空闲已经成为定局。此时我们可以不急着释放那些空间，而将清理的过程延迟一下也并无大碍。因此无需一次清理所有的页，垃圾回收器会视需要逐一进行清理，直到所有的页都清理完毕。这时增量标记又蓄势待发了。


### 并发(Concurrent)
并发式GC允许在在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作。


### 并行
并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。


## V8当前的垃圾回收机制
2011年，V8应用了增量标记机制。直至2018年，Chrome64和Node.js V10启动并发标记（Concurrent），同时在并发的基础上添加并行（Parallel）技术，使得垃圾回收时间大幅度缩短。

### 副垃圾回收器
V8在新生代垃圾回收中，使用并行（parallel）机制，在整理排序阶段，也就是将活动对象从from-to复制到space-to的时候，启用多个辅助线程，并行的进行整理。由于多个线程竞争一个新生代的堆的内存资源，可能出现有某个活动对象被多个线程进行复制操作的问题，为了解决这个问题，V8在第一个线程对活动对象进行复制并且复制完成后，都必须去维护复制这个活动对象后的指针转发地址，以便于其他协助线程可以找到该活动对象后可以判断该活动对象是否已被复制。

### 主垃圾回收器
V8在老生代垃圾回收中，如果堆中的内存大小超过某个阈值之后，会启用并发（Concurrent）标记任务。每个辅助线程都会去追踪每个标记到的对象的指针以及对这个对象的引用，而在JavaScript代码执行时候，并发标记也在后台的辅助进程中进行，当堆中的某个对象指针被JavaScript代码修改的时候，写入屏障（write barriers）技术会在辅助线程在进行并发标记的时候进行追踪。

当并发标记完成或者动态分配的内存到达极限的时候，主线程会执行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次的扫描根集以确保所有的对象都完成了标记，由于辅助线程已经标记过活动对象，主线程的本次扫描只是进行check操作，确认完成之后，某些辅助线程会进行清理内存操作，某些辅助进程会进行内存整理操作，由于都是并发的，并不会影响主线程JavaScript代码的执行。

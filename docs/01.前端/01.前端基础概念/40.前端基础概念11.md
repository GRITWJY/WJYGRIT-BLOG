---
title: 前端基础概念11  
date: 2022-08-12 21:43:34  
permalink: /pages/CMEKO/  
categories:
  - 前端
  - 前端基础概念
tags:
  - 基础
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 前端基础概念11



## 1. >>>, /deep/, ::v-deep 的原理


### scoped
> 多了一个data-v-hash属性，也就是说加了scoped，PostCSS给一个组件中的所有dom添加了
> 一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，
> 这种做法使得样式只作用于含有该属性的dom——组件内部dom，可以使得组件之间的样式不互相污染。
 

**原理**
Vue的作用域样式 `scoped css` 的实现思路如下:

1. 为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件实例的标识符，我称它为组件实例标识，简称实例标识，记作 InstanceID；

2. 给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 `data-v-实例标识`，示例：`<div data-v-e0f690c0="" >`；

3. 给组件的作用域样式 `<style scoped>` 的每一个选择器的最后一个选择器单元增加一个属性选择器 `原选择器[data-v-实例标识]` ，示例：假设原选择器为 `.cls #id > div`，则更改后的选择器为 `.cls #id > div[data-v-e0f690c0]`；

**特点**
1. 将组件的样式的作用范围限制在了组件自身的标签，即：组件内部，包含子组件的根标签，但不包含子组件的除根标签之外的其它标签；所以 组件的css选择器也不能选择到子组件及后代组件的中的元素（子组件的根元素除外）；

> 因为它给选择器的最后一个选择器单元增加了属性选择器 `[data-v-实例标识]` ，
> 而该属性选择器只能选中当前组件模板中的标签；而对于子组件，只有根元素 即有 
> 能代表子组件的标签属性 `data-v-子实例标识`，又有能代表当前组件（父组件）的 
> 签属性 `data-v-父实例标识`，子组件的其它非根元素，仅有能代表子组件的标签
> 属性 `data-v-子实例标识`；

2. 如果递归组件有后代选择器，则该选择器会打破特性1中所说的子组件限制，从而选中递归子组件的中元素；

> 原因：假设递归组件A的作用域样式中有选择器有后代选择器 `div p` ，
> 则在每次递归中都会为本次递归创建新的组件实例，同时也会为该实例生成对应的选择器 `div p[data-v-当前递归组件实例的实例标识]`，
> 对于递归组件的除了第一个递归实例之外的所有递归实例来说，虽然 `div p[data-v-当前递归组件实例的实例标识]` 不会选中子组件
> 实例（递归子组件的实例）中的 p 元素（具体原因已在特性1中讲解），但是它会选中当前组件实例中所有的 p 元素，
> 因为 父组件实例（递归父组件的实例）中有匹配的 div 元素；


### 2. >>>、/deep/、::v-deep深度选择器的原理

如果你希望 scoped 样式中的一个选择器能够选择到子组 或 后代组件中的元素，我们可以使用 `深度作用选择器`，它有三种写法：

- `>>>，示例： .gby div >>> #dyx p`
- `/deep/，示例： .gby div /deep/ #dyx p 或 .gby div/deep/ #dyx p`
- `::v-deep，示例： .gby div::v-deep #dyx p 或 .gby div::v-deep #dyx p`

它的原理与 Scoped CSS 的原理基本一样，只是第3步有些不同（前2步一样），具体如下：

1. 为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件的标识符，我称它为实例标识，记作 InstanceID；

2. 给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 `data-v-实例标识`，示例：`<div data-v-e0f690c0="" >`；

3. 给组件的作用域样式 `<style scoped>` 的每一个深度作用选择器前面的一个选择器单元增加一个属性选择器`[data-v-实例标识]` ，示例：假设原选择器为 `.cls #id >>> div`，则更改后的选择器为 `.cls #id[data-v-e0f690c0] div`；


因为Vue不会为深度作用选择器后面的选择器单元增加 属性选择器`[data-v-实例标识]`，所以，后面的选择器单元能够选择到子组件及后代组件中的元素；



## 2. 正向代理与反向代理


### 正向代理
- 正向代理位于客户端和源服务器之间的服务器（代理服务器）；
- 隐藏客户端：由代理服务器代替客户端去访问目标服务器，用户需要设置代理服务器的IP和端口；
- 每一次请求是到代理服务器，代理服务器转发请求到真实服务器并获取结果返回给客户端

作用:
- 翻墙：绕过无法访问的结点，从另外一条路由路径进行目标服务器的访问；
- 缓存：数据缓存在代理服务器上，如果客户端请求的内容在缓存中则不去访问目标主机；
- 权限控制：防火墙授权代理服务器访问权限，客户端通过正向代理可以通过防火墙；
- 隐藏访问者：通过配置，目标服务器无法获取真实客户端信息，只能获取到代理服务器的信息



### 反向代理
- 对于客户端而言，反向代理服务器像是原始服务器；
- 隐藏真实服务器：代理服务器代替目标服务器去接受并返回客户端的请求

作用：
- 隐藏真实服务器：防止服务器恶意攻击等；
- 缓存作用：数据缓存在代理服务器上，如果客户端请求的内容在缓存中则不去访问目标主机；
- 负载均衡：如nginx


## 3. [重新渲染一个组件, 不改动数据的情况下](https://www.h5w3.com/149728.html)
<img :src= "$withBase('/CMEKO/img.png')" alt = "foo" />



## 4. 什么是 Samesite Cookie 属性？

SameSite 是HTTP响应头 `Set-Cookie` 的属性之一。它允许声明该 Cookie 是否仅限于第一方或者同一站点上下文。

- 将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。

- 将 Samesite 设为 Lax ，这种模式称为宽松模式，也是目前浏览器中的默认值。如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都需要重新登录。还有一个问题就是它的兼容性不够好。

- 将 Samesite 设为 None，Cookie将在所有上下文中发送，即允许跨域发送。

响应头设置方式：

`Set-Cookie: flavor=choco; SameSite=None; Secure`

## 5. 服务端渲染的优点和缺点


**服务端渲染的优点：**

- 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

- 更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

**服务端渲染的缺点：**

- 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

- 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
                         

## 6. IP 协议的首部结构

首部协议一共是20个字节（固定）
- 第一个4字节： 版本号；首部长度； 服务类型；总长度；
- 第二个4字节：标识；标志；片偏移；
- 第三个4字节：生存时间；协议；校验和；
- 第四个4字节：源ip地址；
- 第五个4字节：目的ip地址；



- **版本**：占4位。指IP协议的版本，通讯双方使用的IP版本必须要一致。
- **首部长度**：占4位。最大10进制为15，这里必须要注意单位是4字节。因此首部长度字段的最小值是5（0101），相当于IP首部长度5*4=20字节，此时数据部分长度为0。
- **区分服务**：占8位。用来获得更好的服务。这个字段以前叫服务类型，但是一直都没用到过。后来改为区分服务，只有使用区分服务时，这个字段才有用。
- **总长度**：占16位。指首部和数据之和的长度，单位是字节。
- **标识**：占3位。代表之后有没有分片的数据报。
- **片偏移**：占13位。指较长的数据报在分片之后，处于原位置的相对位置。也就是相对于用户数据字段的起点位置。
- **生存时间**：占8位。一般用TTL标识，就是数据报在网络中的寿命，以防数据报在因特网中循环绕圈，浪费资源。没经过一个路由器时，TTL就减一，当TTL为0时，就抛弃这个数据报。
- **协议**：占8位。指出数据报携带的数据是什么协议，为了让目的主机的IP层知道把数据上交给哪个阶段。
- **首部检验和**：占16位。这个字段只会检测数据报文的首部，不包括数据部分。数据报每次经过路由器，路由器都会计算首部检验和，如果计算结果为0，就保留这个数据报，否则就认为数据报出错，直接丢弃。
- **源地址**：占32位。
- **目标地址**：占32位。
- **可变部分**：1到40字节不等，取决于自己的项目。添加可变部分是为了增强数据报的功能，但是也增加了路由器处理数据的开销。实际上可变部分是很少用的。 
<img :src= "$withBase('/CMEKO/img_1.png')" alt = "foo" />



## 7. 说一说 ajax 的创建过程

1. ajax的全程翻译为中文的话就是异步js和xml，是利用xmlhttprequest技术构建更复杂，动态的网页的编程实践，主要用来实现客户端与服务器端的异步通信，实现页面的局部刷新。网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面

2. 如何实现一个ajax
   - 1.创建一个xmlhttprequest对象
   - 2.向服务器发送请求 
      - 利用open初始化一个请求
      - 利用send发送请求
   - 3.处理服务器响应，使用方法 `readyStatechange` 监测状态变化，如果状态变化，调用回调函数，加入 `readyState` 是`4并且>300响应码>200`，或者等于304，那么就执行成功的回调，否则就执行失败的回调
     
3. readystate的含义：
<img :src= "$withBase('/CMEKO/img_2.png')" alt = "foo" />

4. [status 的含义](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

5. get和post的区别

使用post请求方式的时候，还需要在open和send方法之前调用setRequestHeader，设置http请求头的内容
```javascript
// 1. 创建一个xml对象，使用XMLHttpRequest()方法，ie的话是new ActiveObject('Microoft.XMLHTTP')
var xmlHttp
if (window.XMLHttpRequest) {
    xmlHttp = new XMLHttpRequest()
} else {
    xmlHttp = new ActiveXObject('Microsoft.XMLHTTP')
}
if (option.type.toLowerCase() === 'get') {
    // 2. 调用open指定发送的类型和地址
    xmlhttp.open('GET', url);
    //3.发送请求
    xmlhttp.send();
} else if (option.type.toLowerCase() === 'post') {
    xmlhttp.open('POST', url);
    // 4. 如果是post的话还需要设置http请求头的内容，位于open和send之间
    xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xmlhttp.send(str);
}
// 5. 处理服务器的响应，使用readyStatechange监测状态的变化，触发回调函数
// 6. 如果readyState是4，并且响应码处于200,300，或是等于304，就执行成功的回调
xmlHttp.onreadyStateChange = function () {
    // 返回一个 XMLHttpRequest  代理当前所处的状态（0 unsent 1opened 2 已经调用send了 3下载中 4下载完毕done）
    if (xmlHttp.readyState == 4) {
        // 服务器返回的状态码
        if (xmlhttp.status >= 200 && xmlhttp.status < 300 ||
            xmlhttp.status === 304) {
            console.log(xmlhttp.responseText)
        }
    } else {
        console.log(xmlhttp.status)
    }
}
```


## 8. 说一说虚拟地址空间
<img :src= "$withBase('/CMEKO/img_3.png')" alt = "foo" />

## 9. ReactRouter 的基本用法
react的路由保证了界面和URL的同步，拥有简单的API和强大的功能。react中的路由模式有两种，分别是：hash路由和history路由。

首先用析构的方法引入需要用到的路由方式，需要注意的是路由所有的配置都必须被包裹在hash路由或者history路由里面。

然后在路由标签内先再配置Route标签，它的参数有：path，路由匹配的路径。component，路由匹配成功之后渲染的组件。

react中路由的跳转使用Link标签，它的参数to指路由匹配的路径，也需要引入。NavLink标签和Link的区别就是渲染成a标签之后会自带一个class属性，对应的是NavLink标签的active属性。

react路由中有高阶路由组件withRouter，它和普通路由一样需要引入，主要作用是增加了路由跳转的方式，可以调用history方法进行函数中路由的跳转。

react中路由的动态传值是一个重点，{/:属性名}和{/属性名/值}搭配的方式进行传值，在需要接收参数的组件通过this.props.match.params来进行接收。react中路由的query传值是通过问号的方法将参数拼接在url之后，在需要接收参数的组件通过url.parse(this.props.location.search).query获取参数。

路由的重定向需要用组件Redirect来完成，参数to是目标组件。

路由的懒加载需要从react中引入Suspense和lazy，引入组件时通过lazy(() => import())来引入，使用Suspense标签将Route包裹起来即可。





## 10. 简述一下 Linux 中的零拷贝
- 什么是零拷贝

零拷贝（Zero-Copy）就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。

- 零拷贝的好处

  - 避免操作系统内核缓冲区之间进行数据拷贝操作
  - 避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作
  - 用户应用程序可以避开操作系统直接访问硬件存储
  - 避免不必要的系统调用和上下文切换
  - 数据传输尽量让 DMA 来做，需要拷贝的数据可以先被缓存起来，对数据进行处理尽量让硬件来做


**Linux中零拷贝实现**

Linux 中零拷贝技术实现方式通常有 2 中：

- `mmap() + write()`

mmap() 系统调用函数会直接把内核缓冲区里的数据映射到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。具体过程：

  - 应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里，接着应用进程跟操作系统内核共享这个缓冲区
  - 应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据
  - 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的



- `sendfile()`

在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用 sendfile()。具体过程：

  - 发起 sendfile() 系统调用，操作系统由用户态空间切换到内核态空间
  - 通过 DMA 引擎将数据从磁盘拷贝到内核态空间的输入的 socket 缓冲区中
  - 将数据从内核空间拷贝到与之关联的 socket 缓冲区
  - 将 socket 缓冲区的数据拷贝到协议引擎中
  - sendfile() 系统调用结束，操作系统由用户态空间切换到内核态空间


## 11. React中hooks的优缺点是什么？

**优点：** 
- 代码的可读性强，在使用 `hooks` 之前比如发布/订阅自定义事件被挂载在 `componentDidMount` 生命周期中，然后需要在 `componentWillUnmount` 生命周期中将它清楚，这样就不便于开发者维护和迭代。在使用 `hooks` 之后，通过 `useEffect` 可以将 `componentDidMount生命周期、componentDidUpdate生命周期和componentWillUnmount生命周期`聚合起来，方便代码的维护。 
- 组件层级变得更浅了，在使用hooks之前通常使用高阶组件HOC的方法来复用多个组件公共的状态，增强组建的功能，这样肯定是加大了组件渲染的开销，损失了性能。但是在hooks中可以通过自定义组件useXxx()的方法将多个组件之间的共享逻辑放在自定义hook中，就可以轻松的进行数据互通。
- 不再需要考虑class组件中this指向的问题，hook在函数组件中不需要通过this.state或者this.fn来获取数据或者方法。
  
**缺点：**

- `hooks` 的 `useEffect` 只包括了 `componentDidMount、componentDidUpdate还有componentWillUnmount这三个生命周期`，对于`getSnapshotBeforeUpdate`和`componentDidCatch`等其他的生命周期没有支持。
  
使用 `useEffect` 时候里面不能写太多依赖项，将各个不同的功能划分为多个useEffect模块，将各项功能拆开写，这是遵循了软件设计的“单一职责模式”。

如果遇到状态不同步的情况，使用手动传递参数的形式。如果业务复杂，就使用Component代替hooks，hooks的出现并不是取代了class组件，而是在函数组件的基础上可以实现一部分的类似class组件功能。



## 12. 常见的HTTP协议响应头有哪些？

常见的HTTP响应头有：
- cache-control，设置缓存方式。
- content-type，表明资源文件的类型。
- content-encoding，表明资源的编码。
- server，服务器的版本。
- transfer-encoding，资源是分块发送的。
- expires，设置缓存，优先级比cache-control低。
- connection，表明是长连接还是短连接。
- etag，文件的一个标志。
- refresh，用于重定向。
- access-control-allow-origin，允许跨域的站点。
- access-control-allow-methods，跨域请求的请求方法。
- content-range，文件长度。

加分回答

常见的HTTP响应头有：

- **Cache-Control：**
  - private：默认为private 响应只能够作为私有的缓存，不能再用户间共享
  - public：浏览器和缓存服务器都可以缓存页面信息。
  - must-revalidate：对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
  - no-cache：浏览器和缓存服务器都不应该缓存页面信息。
  - max-age=x：通知浏览器x秒之内不要烦我，自己从缓冲区中刷新。
  - no-store：请求和响应的信息都不应该被存储在对方的磁盘系统中。

- **Content-Type**：text/html;charset=UTF-8，告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

- **Content-Encoding：zip**，告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

- Date：03 Apr 2018 03:52:28 GMT，这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

- Server：Tengine/1.4.6，这个是服务器和相对应的版本，只是告诉客户端服务器信息。

- Transfer-Encoding：chunked。这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

- Expires：Sun, 1 Jan 2000 01:00:00 GMT，这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有max-age=x这个响应头准确的，因为max-age=x中的x是个相对时间，不仅更好理解，也更准确。

- Connection：keep-alive，这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

- Etag：就是一个对象的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。 

- Refresh：用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

- Access-Control-Allow-Origin：代表允许跨域的站点，*星号代表所有站点都可以跨域访问。

- Access-Control-Allow-Methods：允许哪些方法来访问。

- Content-Range：bytes 0-5/7877，指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

延伸阅读

缓存中的cache-control字段优先级是大于expires字段的，cache-control是http1.1提出的，expires是1.0提出的。expires的出现是为了解决浏览器时间被手动更改时候缓存判断的问题。如果两者同时出现，则使用cache-control。

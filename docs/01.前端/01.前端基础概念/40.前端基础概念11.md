---
title: 前端基础概念11  
date: 2022-08-12 21:43:34  
permalink: /pages/CMEKO/  
categories:
  - 前端
  - 前端基础概念
tags:
  - 基础
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 前端基础概念11



## 1. >>>, /deep/, ::v-deep 的原理


### scoped
> 多了一个data-v-hash属性，也就是说加了scoped，PostCSS给一个组件中的所有dom添加了
> 一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，
> 这种做法使得样式只作用于含有该属性的dom——组件内部dom，可以使得组件之间的样式不互相污染。
 

**原理**
Vue的作用域样式 `scoped css` 的实现思路如下:

1. 为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件实例的标识符，我称它为组件实例标识，简称实例标识，记作 InstanceID；

2. 给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 `data-v-实例标识`，示例：`<div data-v-e0f690c0="" >`；

3. 给组件的作用域样式 `<style scoped>` 的每一个选择器的最后一个选择器单元增加一个属性选择器 `原选择器[data-v-实例标识]` ，示例：假设原选择器为 `.cls #id > div`，则更改后的选择器为 `.cls #id > div[data-v-e0f690c0]`；

**特点**
1. 将组件的样式的作用范围限制在了组件自身的标签，即：组件内部，包含子组件的根标签，但不包含子组件的除根标签之外的其它标签；所以 组件的css选择器也不能选择到子组件及后代组件的中的元素（子组件的根元素除外）；

> 因为它给选择器的最后一个选择器单元增加了属性选择器 `[data-v-实例标识]` ，
> 而该属性选择器只能选中当前组件模板中的标签；而对于子组件，只有根元素 即有 
> 能代表子组件的标签属性 `data-v-子实例标识`，又有能代表当前组件（父组件）的 
> 签属性 `data-v-父实例标识`，子组件的其它非根元素，仅有能代表子组件的标签
> 属性 `data-v-子实例标识`；

2. 如果递归组件有后代选择器，则该选择器会打破特性1中所说的子组件限制，从而选中递归子组件的中元素；

> 原因：假设递归组件A的作用域样式中有选择器有后代选择器 `div p` ，
> 则在每次递归中都会为本次递归创建新的组件实例，同时也会为该实例生成对应的选择器 `div p[data-v-当前递归组件实例的实例标识]`，
> 对于递归组件的除了第一个递归实例之外的所有递归实例来说，虽然 `div p[data-v-当前递归组件实例的实例标识]` 不会选中子组件
> 实例（递归子组件的实例）中的 p 元素（具体原因已在特性1中讲解），但是它会选中当前组件实例中所有的 p 元素，
> 因为 父组件实例（递归父组件的实例）中有匹配的 div 元素；


### 2. >>>、/deep/、::v-deep深度选择器的原理

如果你希望 scoped 样式中的一个选择器能够选择到子组 或 后代组件中的元素，我们可以使用 `深度作用选择器`，它有三种写法：

- `>>>，示例： .gby div >>> #dyx p`
- `/deep/，示例： .gby div /deep/ #dyx p 或 .gby div/deep/ #dyx p`
- `::v-deep，示例： .gby div::v-deep #dyx p 或 .gby div::v-deep #dyx p`

它的原理与 Scoped CSS 的原理基本一样，只是第3步有些不同（前2步一样），具体如下：

1. 为每个组件实例（注意：是组件的实例，不是组件类）生成一个能唯一标识组件的标识符，我称它为实例标识，记作 InstanceID；

2. 给组件模板中的每一个标签对应的Dom元素（组件标签对应的Dom元素是该组件的根元素）添加一个标签属性，格式为 `data-v-实例标识`，示例：`<div data-v-e0f690c0="" >`；

3. 给组件的作用域样式 `<style scoped>` 的每一个深度作用选择器前面的一个选择器单元增加一个属性选择器`[data-v-实例标识]` ，示例：假设原选择器为 `.cls #id >>> div`，则更改后的选择器为 `.cls #id[data-v-e0f690c0] div`；


因为Vue不会为深度作用选择器后面的选择器单元增加 属性选择器`[data-v-实例标识]`，所以，后面的选择器单元能够选择到子组件及后代组件中的元素；



## 2. 正向代理与反向代理


### 正向代理
- 正向代理位于客户端和源服务器之间的服务器（代理服务器）；
- 隐藏客户端：由代理服务器代替客户端去访问目标服务器，用户需要设置代理服务器的IP和端口；
- 每一次请求是到代理服务器，代理服务器转发请求到真实服务器并获取结果返回给客户端

作用:
- 翻墙：绕过无法访问的结点，从另外一条路由路径进行目标服务器的访问；
- 缓存：数据缓存在代理服务器上，如果客户端请求的内容在缓存中则不去访问目标主机；
- 权限控制：防火墙授权代理服务器访问权限，客户端通过正向代理可以通过防火墙；
- 隐藏访问者：通过配置，目标服务器无法获取真实客户端信息，只能获取到代理服务器的信息



### 反向代理
- 对于客户端而言，反向代理服务器像是原始服务器；
- 隐藏真实服务器：代理服务器代替目标服务器去接受并返回客户端的请求

作用：
- 隐藏真实服务器：防止服务器恶意攻击等；
- 缓存作用：数据缓存在代理服务器上，如果客户端请求的内容在缓存中则不去访问目标主机；
- 负载均衡：如nginx


## 3. [重新渲染一个组件, 不改动数据的情况下](https://www.h5w3.com/149728.html)
<img :src= "$withBase('/CMEKO/img.png')" alt = "foo" />



## 4. 什么是 Samesite Cookie 属性？

SameSite 是HTTP响应头 `Set-Cookie` 的属性之一。它允许声明该 Cookie 是否仅限于第一方或者同一站点上下文。

- 将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。

- 将 Samesite 设为 Lax ，这种模式称为宽松模式，也是目前浏览器中的默认值。如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都需要重新登录。还有一个问题就是它的兼容性不够好。

- 将 Samesite 设为 None，Cookie将在所有上下文中发送，即允许跨域发送。

响应头设置方式：

`Set-Cookie: flavor=choco; SameSite=None; Secure`

## 5. 服务端渲染的优点和缺点


**服务端渲染的优点：**

- 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

- 更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

**服务端渲染的缺点：**

- 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

- 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。
                         



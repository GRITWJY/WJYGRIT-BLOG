---
title: 从输入url到网页出现发生了什么
date: 2022-06-04 10:26:34
permalink: /pages/kaoenfk/
categories:
  - 前端
  - 前端基础概念
tags:
  - 优化
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 从输入url到网页出现发生了什么

[[TOC]]


- [ ] 补充MINME类型嗅探
- [ ] 补充CORB相关

关于这个问题，大家可能都很容易在网上找到很多博客，以为就博客中的内容就差不多完了。没错，是这样，但很多博客都是一个
总结性的陈述， 即忽略了非常多的细节和知识点，相当于用白话文来讲，这对于我们计算机专业的人是用处不大的。所以，我在
查找了众多书籍和国内外博客后，总结除了这一篇文章，里面将会有很多术语和外链，花点时间总是会理解的

文章策略：我会把这一流程分为几步(具体的等我写完再说)， 然每一步的都有概述+详细两个部分，即概述部分可以用来面试时回答
流程的问题，然后详细部分则是被问到某一步中具体的情况， 整个文章组织过程中我尽量用 `问题+答案` 的形式展示，这样方便大家理解和学习

另外：虽然我进行了总结，但还是推荐大家阅读原文，所有的参考连接我都放在文章最底下了
<img :src="$withBase('/kaoenfk/img.png')" alt='foo'/>




## 基础知识：浏览器结构


这里主要讨论`chrome浏览器`的的结构, 而且，这里面我就都用`进程和线程` 去描述。`顶部是与处理应用程序不同部分的其他进程协调的浏览器进程。` 对于渲染进程，会创建多个进程
并分配到每个选项卡。 
<img :src="$withBase('/kaoenfk/img15.png')" alt='foo'/>

### 每个进程都控制着什么
- `浏览器进程(Browser Process), `控制着浏览器的部分应用程序，包括地址栏，书签，前进后退等按钮。还处理网络浏览器中不可见的特权部分，例如网络请求和文件访问。
- 渲染进程，控制显示网站选项卡内的任何内容
- 插件进程，控制网站插件
- GPU进程，与其他进程隔离处理 GPU 任务。它被分成不同的进程，因为 GPU 处理来自多个应用程序的请求并将它们绘制在同一个表面上。


## step1 处理输入

当用户开始在地址栏中输入内容时，`UI 线程` 询问的第一件事是“这是搜索查询还是 URL？”。在 Chrome 中，地址栏也是一个搜索输入字段，因此 `UI 线程需要解析并决定是将您发送到搜索引擎还是您请求的站点`。

## step2 开始导航
当用户点击回车时，`UI 线程会发起网络调用以获取站点内容`。加载微调器显示在选项卡的一角，`网络线程通过适当的协议`，如 `DNS 查找和为请求建立 TLS 连接`。

此时，网络线程可能会收到 `HTTP 301 之类的服务器重定向标头`。在这种情况下，`网络线程与服务器请求重定向的UI线程通信`。然后，将发起另一个 URL 请求。



### DNS Lookup

浏览器解析域名拿到对应的IP地址后，才能和服务器进行通信。

DNS服务器的层次结构包括
- 根域名服务器
- 顶级域名服务器， 如.com/.net/
- 权威服务器

还有一个Local DNS, 用户上网需要通过ISP的网络接入互联网， ISP 会分配给用户一个DNS服务器，这个DNS代理域名解析请求给
最终权威的DNS， 它具有cache能力，如果Local DNS 在 TTL 时间内有cache， 不会迭代向根域、顶级域、和权威域发送DNS

#### 递归查询、迭代查询
这里根据这张图来进行解说，图中 主机 `cse.nyu.edu` 想要获取 主机`gaia.cs.umass.edu` 的
<img :src="$withBase('/kaoenfk/img2.png')" alt='foo'/>

1、 首先， 主机 `cse.nyu.edu` 向它的 `本地DNS服务器: dns.nyu.edu` 发送一个DNS查询报文，  该报文包括 被转换的主机名`gaia.cs.umass.edu`

2、 `本地DNS服务器`将报文转发到 `根DNS服务器`

3、 `根DNS服务器` 注意到 `.edu前缀`， 并向`本地DNS服务器`返回 `负责.edu的TLD的IP地址列表`。 意识是： 我不知道它的IP地址，但这些TLD可能知道

4、 `本地DNS服务器` 向这些`TLD服务器之一`发送查询报文

5、 该TLD服务器 注意到 `umass.edu前缀`， 并返回 `权威服务器的IP地址：dns.umass.edu`

6、 最后，本地服务器向 `dns.umass.edu`发送查询报文， `dns.umass.edu` 就用 `gaia.cs.umass.edu` 的IP地址进行响应

其中`递归查询`是 `主机cse.nyu.edu` 向 `dns.nyu.edu` 发出的查询， 因为这是 自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机

而后继的三个查询是`迭代查询`，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。

#### DNS缓存

在一个 DNS 查询的过程中，当某一台 DNS 服务器接收到一个 DNS 应答（例如，包含某主机名到 IP 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存里的内容。当然，缓存并不是永久的，每一条映射记录都有一个对应的生存时间，一旦过了生存时间，这条记录就应该从缓存移出。

事实上，有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器，需要向根 DNS 服务器发起查询的请求很少。


到这里，DNS的基本流程就已经了解清楚了， 在这部分也可以优化， 不过这个就留到之后做的项目大到需要优化的时候吧


### 建立TCP连接
这部分我以TCP的三次握手和四次挥手的流程来讲
<img :src="$withBase('/kaoenfk/img3.png')" alt='foo'/>

先看下`TCP的头部`， 这里只把需要关注的标注出来了, 对于三次握手和四次挥手，我们需要关注的就是 TCP 的头部`序列号、确认号以及几个标记为 SYN/FIN/ACK/RST`
- **序列号：** 在初次建立连接的时候，客户端和服务端都会为「本次的连接」随机初始化一个序列号。（纵观整个TCP流程中，序列号可以用来解决网络包乱序的问题）
- **确认号：** 该字段表示「接收端」告诉「发送端」对上一个数据包已经成功接收（确认号可以⽤来解决网络包丢失的问题）
- 而**标记位**就很好理解啦。SYN为1时，表示希望创建连接。ACK为1时，确认号字段有效。FIN为1时，表示希望断开连接。RST为1时，表示TCP连接出现异常，需要断开。

#### 三次握手

**三次握手的过程其实就是在： 确认通信双方的序列号**

- **初始化：** 客户端和服务端都处于 CLOSE 状态， 服务器主动监听某个端口，处于 LISTEN 状态
- **客户端的第一次握手：** 客户端会随机生成出序列号（这里的序列号一般叫做client_isn），并且把标志位设置为SYN（意味着要连接），然后把该报文发送给服务端，客户端发送完成后自己进入 `SYN_SEND`状态
<img :src="$withBase('/kaoenfk/img3.png')" alt='foo'/>

- 服务端接收到了客户端的请求之后，自己也初始化对应的序列号（这里的序列号一般叫做 server_isn）
- 在「确认号」字段里填上client_isn + 1（相当于告诉客户端，已经收到了发送过来的序列号了） ，并且把 SYN 和 ACK 标记位都点亮(置为1)
- 把该报文发送客户端，服务端的状态变成 SYN-REVD 状态
<img :src="$withBase('/kaoenfk/img5.png')" alt='foo'/>


- 客户端收到服务端发送的报文后，就知道服务端已经接收到了自己的序列号（通过确认号就可以知道），并且接收到了服务端的序列号(server_isn)
- 此时，客户端需要告诉服务端自己已经接收到了他发送过来的序列号，所以在「确认号」字段上填上server_isn+1，，并且标记位 ACK 为1
<img :src="$withBase('/kaoenfk/img6.png')" alt='foo'/>


- 客户端在发送报文之后，进入 ESTABLISHED 状态，而服务端接收到客户端的报文之后，也进入 ESTABLISHED 状态
- 这就是三次握手的过程以及涉及到的TCP状态
- 总结下来，就是双方都把自身的序列号发给对方，看对方能不能接收到。如果「确认可以」，那就可以正常通信。（三次握手这个过程就可以看到双方都有接收和发送的能力）

问题：

**1、 两次握手行吗？** 两次握手只能保证客户端的序列号成功被服务端接收，而服务端是无法确认自己的序列号是否被客户端成功接收。所以是不行的


**2.序列号为什么是随机的？以及序列号是怎么生成的？**

先看个正常的场景，其中C假冒A给B通信
<img :src="$withBase('/kaoenfk/img7.png')" alt='foo'/>

由于ISN是随机的， B响应后， 就不知道 ISN_B， 最终则直接终止连接。

若不是随机的，C能推出ISN_B， 那么它就可以模拟一个ACK，最终建立通信

总结来说，一方面为了安全性（随机ISN能避免非同一网络的攻击），另一方面可以让通信双方能够根据序号将「不属于」本连接的报文段丢弃
<img :src="$withBase('/kaoenfk/img8.png')" alt='foo'/>


**3.既然网络是不可靠的，那建立连接不是会经过三次握手吗？那要是在中途丢了，怎么办？**

**假设第一个包丢了，** 客户端发送给服务端的 SYN 包丢了（简而要之就是服务端没接收到客户端的SYN包） ,客户端迟迟收不到服务端的ACK包，那会周期性超时重传，直到收到服务端的ACK

**假设第二个包丢了，** 服务端发送的SYN+ACK包丢了（简而要之就是客户端没接收到服务端的SYN+ACK包） , 服务端迟迟收不到客户端的ACK包，那会周期性超时重传，直到收到客户端的ACK

**假设第三个包丢了（ACK包）**，客户端发送完第三个包后单方面进入了 ESTABLISHED 状态，而服务端也认为此时连接是正常的，但第三个包没到达服务端
- 一、如果此时客户端与服务端都还没数据发送，那服务端会认为自己发送的SYN+ACK的包没发送至客户端，所以会超时重传自己的SYN+ACK包
- 二、如果这时候客户端已经要发送数据了，服务端接收到了ACK + Data数据包，那自然就切换到 ESTABLISHED 状态下，并且接收客户端的Data数据包
- 三、如果此时服务端要发送数据了，但发送不了，会一直周期性超时重传SYN + ACK，直到接收到客户端的ACK包


#### 四次挥手
以客户端主动断开为例

客户端会发送`FIN报文`给服务端， 客户端发送完毕后，就进入`FIN_WAIT_1`状态

服务端接收到`FIN报文`后，回复 `ACK报文`给客户端， 服务端发送完之后，就进入 `CLOSE_WAIT`状态

客户端接收到服务端的`ACK报文`后， 就进入 `FIN_WAIT_2`状态
<img :src="$withBase('/kaoenfk/img9.png')" alt='foo'/>


这时候，服务器可能还有数据要发送给客户端，等服务端确认自己已经 `没有数据返回给客户端之后` ，就发送 `FIN报文给客户端`了，自己进入 `LAST_ACK 状态`

客户端收到服务端的`FIN报文`之后，回应`ACK报文`，自己进入 `TIME_WAIT 状态`

服务端收到客户端的`ACK报文`之后，服务端就进入 `CLOSE 状态`

客户端在`TIME_WAIT等到2MSL`，也进入了 `CLOSE 状态`
<img :src="$withBase('/kaoenfk/img10.png')" alt='foo'/>


**问题**

**1.为什么是四次呢**

其实很好理解，当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK给客户端

等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，表示可以关闭了。

所以，一来一回就四次了。

**2.从四次挥手的流程上来看，有个 TIME_WAIT 状态，你知道这个状态干什么用的吗？（等待 2MSL）**

主要有两个原因吧。1.保证最后的 ACK 报文 「接收方」一定能收到（如果收不到，对方会 重发 FIN 报文）2. 确保在创建新连接时，先前网络中残余的数据都丢失了

其实也比较好理解的。就正如我们重启服务器一样，会先优雅关闭各种资源，再留有一段时间，希望在这段时间内，资源是正常关闭的，这样重启服务器（或者发布）就基本认为不会影响到线上运行了。


**3.假设 TIME_WAIT 状态多过会有什么危害？怎么解决呢？**

主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长

在socket的TIME_WAIT状态结束之前，该socket所占用的本地端口号将一直无法释放。这也是文章开头的提到问题的一个原因之一。

在高并发（每秒几万qps）并且采用短连接方式进行交互的系统中运行一段时间后，系统中就会存在大量的time_wait状态，如果time_wait状态把系统所有可用端口 都占完了且尚未被系统回收时，就会出现无法向服务端创建新的socket连接的情况。此时系统几乎停转，任何链接都不能建立。


**4.TCP连接，那这个连接到底是什么？你是怎么理解的？**

该连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。前面讲过，由于TCP协议只在端系统中运行，而不在
中间的网络元素中运行，所以中间网络元素是不会维持TCP连接状态。



## step3 读取回复

一旦`响应主体（有效负载）`开始进入，`网络线程会在必要时查看流的前几个字节`。`响应的 Content-Type 标头应该说明它是什么类型的数据`，但由于它可能丢失或错误，因此在这里进行[MIME 类型嗅探](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 。     
<img :src="$withBase('/kaoenfk/img16.png')" alt='foo'/>


如果响应是一个 HTML 文件，那么下一步就是将数据传递给渲染器进程，但如果它是一个 zip 文件或其他文件，那么这意味着它是一个下载请求，所以他们需要将数据传递给下载管理器。
<img :src="$withBase('/kaoenfk/img17.png')" alt='foo'/>


这也是进行`安全浏览检查`的地方。如果`域【domain】和响应数据似乎与已知的恶意站点相匹配`，则网络线程会发出警报以显示警告页面。此外，[(CORB )检查](https://www.chromium.org/Home/chromium-security/corb-for-developers/)是为了确保敏感的跨站点数据不会进入渲染器进程


### MIME sniffing

在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行 MIME 嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 Content-Type 来设置 X-Content-Type-Options 以阻止 MIME 嗅探。

如果想看下转换策略，可以看看[源码](https://source.chromium.org/chromium/chromium/src/+/main:net/base/mime_sniffer.cc;l=5)


### How can I ensure CORB protects resources on my website?




## step4 找一个渲染进程
`一旦完成所有检查并且网络线程确信浏览器应该导航到请求的站点`，网络线程就会告诉 UI 线程数据已准备好。`UI线程然后找到一个渲染器进程来进行网页的渲染。`
<img :src="$withBase('/kaoenfk/img18.png')" alt='foo'/>


`由于网络请求可能需要数百毫秒才能得到响应`，因此应用了加速此过程的优化。`当 UI 线程在第 2 步向网络线程发送 URL 请求时`，它已经知道他们正在导航到哪个站点。UI 线程尝试主动查找或启动与网络请求并行的渲染器进程。这样，如果一切按预期进行，当网络线程接收到数据时，渲染器进程已经处于待机位置。如果导航重定向跨站点，则可能不会使用此备用进程，在这种情况下，可能需要不同的进程。

### 渲染器处理web内容

这部分内容比较多，[我就单独用一篇文章来写](https://wjygrit.cn/pages/ABCMEL/)

如果只想看个`超简概述`的话，可以看看下面这个

这部分只做简单概述，这里有一篇关于浏览器的详细描述，需要了解核心原理的可以看这篇文章
服务器返回HTTP Response后， 浏览器陆续开始接收数据，进行HTML下载、解析、渲染显示等过程。具体步骤如下
- 1、 如果是Gzip包，则先解压
- 2、 解析HTML的头部代码，下载头部代码中引用的样式资源文件或者脚本文件
- 3、 解析HTML代码和样式文件代码， 这个过程会构造出两个树结构，即与HTML相关的DOM树，以及与CSS相关的CSSOM树。
- 4、 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造出渲染树
- 5、 根据渲染树完成绘制过程

<img :src="$withBase('/kaoenfk/img10.png')" alt='foo'/>

浏览器下载HTL后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构造DOM树，同时进行样式下载。
DOM树构建完成后，立即开始构造CSSOM树。如果样式表的下载速度够快，DOM树和CSSOM树就会进入一个并行进程，
当两颗树准备完毕，即可开始构造渲染树，最后进行绘制。

而在真实页面解析过程中，浏览器通常会因为各种因素被阻断

- 1、 HTML代码中的JS代码会阻断DOM树的构造，因为浏览器认为这段JS代码可能会修改DOM结果，所以必须等待JS代码执行完毕，再恢复DOM树的构造过程。这是由浏览器的安全解析策略决定的，目前并没有指定某个JS代码不涉及DOM的属性
- 2、 浏览器必须等待样式表加载完成，才能开始构建CSSOM树
- 3、 还有一种特殊情况，浏览器在解析HTML时遇到JS代码，而此时CSSOM树还未构建完成，则浏览器会暂停脚本执行(浏览器同时也会暂停继续向下解析HTML代码，从而导致DOM树的构建过程被暂停阻塞)，直到CSS样式文件下载完成，并完成CSSOM树的构建，才会重新恢复原来的解析。这是由浏览器的安全解析策略决定的


通过对上面因素的分析，我们可以发现，HTML中的内联JS代码执行的危害之处，不在于它阻断了DOM树的构建过程，除非是一段特别恶劣的JS代码运行非常慢，通常内联的JS代码运行大概
消耗十几毫秒，也就是暂停构建几毫秒到几十毫秒。 它最大的危害在于第三种情况，即DOM树构建被阻塞的时间不只是JS代码运行的时间，而是会加上样式资源文件下载和CSSOM树的构建时间，
这时浏览器所进行的串行解析过程，与我们在前面期望的DOM树和CSSOM树的并行解析过程相差甚远
<img :src="$withBase('/kaoenfk/img13.png')" alt='foo'/>
<img :src="$withBase('/kaoenfk/img14.png')" alt='foo'/>


## step5 提交导航

`现在数据和渲染器进程已准备就绪`，`从浏览器进程向渲染器进程发送 IPC 以提交导航`。它还传递数据流，因此渲染器进程可以继续接收 HTML 数据。一旦浏览器进程听到在渲染器进程中发生提交的确认，导航就完成了，文档加载阶段开始了。

此时，地址栏更新，安全指示器和站点设置 UI 反映了新页面的站点信息。该选项卡的会话历史记录将被更新，因此后退/前进按钮将逐步浏览刚刚导航到的站点。为了在您关闭选项卡或窗口时促进选项卡/会话恢复，会话历史记录存储在磁盘上。
<img :src="$withBase('/kaoenfk/img19.png')" alt='foo'/>



## 额外: 渲染进程处理 web内容

这部分是针对[浏览器渲染部分工作原理](http://wjygrit.cn/pages/ABCMEL)的一个概述, 重复写了这么多只是为了去理解这部分内容,
因为这部分内容实在太多了, 而面试中又不可能一次性全说出来, 只能先进行整理, 然后问道具体点再具体回答.

当然, 这里还是得靠自己的学习和理解哈,仅看几篇博客是不能掌握的.

`如果问道了详细一点的,可以按照这个回答`,如果问道了其中某一步骤中更详细的,就基本上靠自己的`学习深度`了



渲染器进程的核心是将HTML/css和JS转换为用户可以与之交互的网页, 总结起来就是在做 `解析`.
解析过程主要包括  `DOM树构建`, `呈现树构建`, `布局`, `绘制`,`动态变化`,`事件循环`, `合成`,`分层`

### DOM树构建
当渲染器进程接收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串 (HTML) 并将其转换为文档对象模型( DOM )。
DOM 是浏览器对页面的内部表示，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。


网站通常使用图像、CSS 和 JavaScript 等外部资源。这些文件需要从网络或缓存中加载。主线程可以在解析构建DOM的过程中找到它们时一一请求，但为了加快速度，“预加载扫描器”是并发运行的。如果 HTML 文档中有类似的东西`<img>`，`<link>`预加载扫描器会查看 HTML 解析器生成的令牌，并向浏览器进程中的网络线程发送请求。

当 HTML 解析器找到一个`<script>`标签时，它会暂停 HTML 文档的解析，并且必须加载、解析和执行 JavaScript 代码。为什么？`document.write()`因为 JavaScript 可以通过改变整个 DOM 结构之类的东西来改变文档的形状（HTML 规范中解析模型的概述有一个很好的图表）。这就是为什么 HTML 解析器必须等待 JavaScript 运行才能恢复对 HTML 文档的解析。

Web 开发人员可以通过多种方式向浏览器发送提示，以便更好地加载资源。如果您的 JavaScript 不使用`document.write()`，您可以添加async或defer属性到`<script>`标记。然后浏览器异步加载和运行 JavaScript 代码，并且不会阻止解析。如果合适的话，你也可以使用JavaScript 模块。`<link rel="preload">`是一种通知浏览器当前导航肯定需要该资源并且您希望尽快下载的方法。

## 总结
我之前在网上找了挺多的博客，但都没有一个把这个事件与浏览器结合起来，从浏览器的导航栏开始，讲述每一步是哪几个进程和线程在控制的，
以及怎么控制的，而网上的博客基本上就只是按阶段来讲，这个阶段主要干啥干啥， 结果就是 一旦面试官问的深一点，就啥也不知道。

:::tip 注意
- 看国内的博客时，先看底下是否有参考链接的，没有的一律不看，这种90%的情况下是复制的(我自己呃文章之后会慢慢补上的)
- 找到参考链接后，再顺着找下去，看有没有国外的， 有的话就把原博客看完后， 再去深入研究国外的博客文章，此时你就有很大几率接触到官方文档
- 如果碰到官方文档比较多的话，计划好，慢慢翻译，翻译完你就胜利了
:::


## 参考资料
- [TCP进行通信时的初始序列号为什么是随机的](https://blog.csdn.net/qq_42950328/article/details/111477158)
- [为什么TCP的初始序列号ISN是随机生成的？](https://blog.csdn.net/weixin_44164489/article/details/108538996)
- [面试官问我TCP三次握手和四次挥手，我真的是](https://juejin.cn/post/7045059219216662564)
- [分析关键渲染路径性能](https://web.dev/critical-rendering-path-analyzing-crp/)
- [浏览器工作原理](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [浏览器如何工作的](http://taligarsiel.com/Projects/howbrowserswork1.htm)
- [Inside look at modern web browser](https://developer.chrome.com/blog/inside-browser-part1/)

- [MIME sniffing](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types#mime_%E5%97%85%E6%8E%A2)
- [mime sniffing源码](https://source.chromium.org/chromium/chromium/src/+/main:net/base/mime_sniffer.cc;l=5)
- [Cross-Origin Read Blocking for Web Developers](https://www.chromium.org/Home/chromium-security/corb-for-developers/)

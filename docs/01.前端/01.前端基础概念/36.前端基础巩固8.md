---
title: 前端基础巩固8  
date: 2022-07-19 21:37:34  
permalink: /pages/OEKDOE/  
categories:
    - 前端
    - 前端基础概念
tags:
    - 基础
    - 面试
author:  
    name: WJYGRIT   
    link: https://github.com/GRITWJY  
---

# 前端基础巩固8

[[toc]]


## 1. window.onload 和 DOMContentLoaded 的区别

window 的load事件会在页面完全加载后触发，**因为要等待很多外部资源加载完成**,
所以会花费较长时间。而**`DOMContentLoaded`**事件会在DOM树构建完成后立即触发，
而**不用等待图片、JavaScript文件、CSS文件或其他资源加载完成**。
相对于load事件，**DOMContentLoaded可以让开发者在外部资源下载的同时就能指定事件处理程序**，
从而让用户能够更快地与页面交互。

对于不支持DOMContentLoaded事件的浏览器，可以使用超时为0的setTimeout()函数，通过其回调来设置事件处理程序，比如
```javascript
setTimeout(()=>{
   // 在这里添加事件处理程序 
},0)
```
以上代码本质上意味着在当前JavaScript进程执行完毕后立即执行这个回调. 
**原理:** **页面加载和构建期间，只有一个 JavaScript 进程运行**。**所以可以在这个进程空闲后立即执行回调，至于是否与同一个浏览器或同一页面上不同脚本的DOMContentLoaded触发时机一致并无绝对把握。**为了尽可能早一些执行，以上代码最好是页面上的第一个超时代码。即使如此，考虑到各种影响因素，也不一定保证能在load事件之前执行超时回调。

## 2. 如何封装一个弹窗组件，需要考虑哪些方面
- 组件标题，按钮文案，按钮个数、弹窗内容都可定制化;vue
- 弹窗垂直水平居中 考虑实际在微信环境头部不可用，ios微信环境中底部返回按钮的空间占用;
- 遮罩层和弹窗内容分离，点击遮罩层关闭弹窗;
- 多个弹窗同时出现时弹窗的z-index要不以前的要高;
- 点击遮罩层关闭弹窗和处理弹窗底部的页面内容不可滚动.

## 3. 说一下vue如何做到样式隔离
scoped

- 当 style 标签加上 scoped 属性时，scoped 会在 DOM 结构及 css 样式上加上唯一性的标记 data-v-xxx 属性，从而达到样式私有化，不污染全局的作用；

>
> Scope CSS 的本质是基于 HTML 和 CSS 属性选择器，即分别给 HTML 标签和 CSS 选择器添加data-v-xxx；
>
> 具体来说，它是 通过 vue-loader 实现 的，实现过程大致分 3 步：
>
> 1.首先 vue-loader 会解析 .vue 组件，提取出 template、script、style 对应的代码块；
>
> 2.然后构造组件实例，在组件实例的选项上绑定 ScopedId；
>
> 3.最后对 style 的 CSS 代码进行编译转化，应用 ScopedId 生成选择器的属性；


## 4. 频繁使用EventBus会造成什么问题？

如果不及时取消订阅，回调函数会继续执行，如果回调函数中引用了外部变量形成闭包，则会导致内存泄漏

销毁组件无法解决这个问题，因为回调函数绑定在了vue的实例对象上，因此需要调用 `this.$eventbus.$off` 取消对事件的订阅。

## 5. 刷新浏览器后，Vuex的数据是否存在？如何解决？
- 可以直接将vuex的数据保存在浏览器中, (sessionStorage, localstorage, cookie)
- 页面刷新时再次请求远程数据, 使之动态更新
- 在父页面向后台请求远程数据, 并且在页面刷新前将 vuex 的数据保存至 `sessionStorage`, 刷新成功后如果数据还没返回, 则直接拿sessionStorage里的数据, 否则拿新的数据

## 6. 在Vue中，设置全局变量的方式有哪些？
- 使用全局变量专用模块, 挂载到 Vue.prototype
```javascript
// global.vue
const token = '244'
const userStatus = false
export default {
    token,
    userStatus
}

// main.js
import global from './global.vue'
Vue.prototype.GLOBAL = global

// 使用
this.GLOBAL.token
```

- 使用 vuex 定义全局变量
```javascript
// index.js文件里定义vuex
import state from './state'
export default new Vuex.Store({
 actions,
 getters,
 mutations,
 state,
})
// state.js里面存放全局变量，并且暴露出去
const state = {
 token:'12345678',
 language: 'en',
}

export default state

// 使用

this.$store.language

```

- 定义全局函数
```javascript
// base.js
exports.install = function (vue,options) {
    Vue.prototype.changeData = function () {
        alert('执行成功')
    }
}

// main.js
import base from './base'
Vue.use(base)
```

## 7. 如何理解Vue的单向数据流？
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。

另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

这里有两种常见的试图变更一个 prop 的情形：
- 1. 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 作为其初始值：
```
props: ['initialCounter'],
data() {
  return {
    counter: this.initialCounter
  }
}
```

- 2. 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性
```javascript
props: ['size'],
computed: {
  normalizedSize() {
    return this.size.trim().toLowerCase()
  }
}
```



## 8. 手写assign，要考虑全面，包括symbol也要考虑在内
```javascript
  let obj1 = {
    a:1,
    b:2
  }
  obj1[Symbol('abc')] = 'abc'
  let obj2 = {
    a:3,
    d:5
  }
  obj2[Symbol('abc')] = 'abc'
  function myAssign(...objs){
    let res = {}
    for(let obj of objs){
      for(let prop of Reflect.ownKeys(obj)){
        res[prop] = obj[prop]
      }
    }
    return res
  }
  let obj3 = myAssign(obj1,obj2)
  console.log(obj3)
```


## 9. vuex的原理
利用了全局混入Mixin，将你所创建的store对象，混入到每一个Vue实例中，那么全局混入是什么呢？

## 10. 用promise封装实现readfile和writefile的同步请求（写代码）
```javascript
const fs = require('fs')
function fsRead(path){
	return new Promise((resolve,reject)=>{
		fs.readFile(path,'utf-8',(err,data)=>{
			if(err){
				reject(err)
			}else{
				resolve(data)
			}
		})
	})
}
function fsRead(path,content){
	return new Promise((resolve,reject)=>{
		fs.readFile(path,content,'utf-8',(err)=>{
			if(err){
				reject(err)
			}else{
				resolve('修改成功')
			}
		})
	})
}
```

## 11. jwt认证机制的理解，它的优缺点

**传统session**
- 用户向服务器发送用户名和密码。
- 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
- 服务器向用户返回一个 session_id，写入用户的 Cookie。 
- 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。
- 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。

**缺点**
- session保存在服务器，当注册用户很多，会增加服务器的开销。
- 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。
- session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造（CSRF）的攻击。

**jwt认证**

JWT是基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

**流程**
- 用户使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了`Access-Control-Allow-Origin: *`。

**缺点**

- 由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。

## 11. 说一下你知道的纯函数
- 它应始终返回相同的值。不管调用该函数多少次，无论今天、明天还是将来某个时候调用它。
- 自包含（不使用全局变量）。
- 它不应修改程序的状态或引起副作用（修改全局变量）。


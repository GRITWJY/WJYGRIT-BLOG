---
title: 前端基础巩固12  
date: 2022-08-21 20:55:34  
permalink: /pages/ALEKD/  
categories:
  - 前端
  - 前端基础概念
tags:
  - 基础
author:  
  name: WJYGRIT   
  link: https://github.com/GRITWJY
---

# 前端基础巩固12

## 1. 说一说vue钩子函数？

:::details
钩子函数用来描述一个组件从引入到退出的全过程中的某个过程，整个过程称为生命周期。 

钩子函数按照组件生命周期的过程分为，挂载阶段=>更新阶段=>销毁阶段。 每个阶段对应的钩子函数 

- 挂载阶段：`beforeCreate、created、beforeMounted、mounted`
  
- 更新阶段：`beforeUpdate、updated`
  
- 销毁阶段：`beforeDestroy、destroyed` 
  
**每个阶段特点与适合做什么** 

- `created：` 实例创建完成，可访问`data、computed、watch、methods`上的方法和数据，未挂载到DOM，不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求，页面的初始化
  
- `beforeMount：`在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 
  
- `mounted：`实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求 
  
- `beforeupdate：` 响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 
  
- `updated：`虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作避免在这个钩子函数中操作数据，可能陷入死循环 
  
- `beforeDestroy：`实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例，常用于销毁定时器、解绑全局事件、销毁插件对象等操作 
  

父子组件钩子函数在三个阶段的代码执行顺序
- 挂载：`父亲created> 子created > 子mounted> 父亲mounted>` 
  
- 更新：`父亲beforeUpdate > 子beforeUpdated > 子updated > 父亲updated` 
  
- 销毁：`父亲beforeDestroy> 子beforeDestroy > 子destroyed> 父destroyed`
:::



## 2. 当 margin-top、padding-top 的值是百分比时，分别是如何计算的？
CSS 百分比参照问题

参照父元素宽度的元素：padding margin width text-indent

参照父元素高度的元素：height

参照父元素属性:font-size line-height

特殊：相对定位的时候，top(bottom) left(right)参照的是父元素的内容区域的高度与宽度，而绝对定位的时候参照的是最近的定位元素包含padding的高度与宽度


## 3.ES6转成ES5 的思路

Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

- 解析（parse）：将代码字符串解析成抽象语法树，即所谓的 AST

- 转换（transform）：对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码

- 生成（generate）：根据处理后的 AST 再生成代码字符串


于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。

可以使用 @babel/parser 的 parse 方法，将代码字符串解析成 AST；

使用 @babel/core 的 transformFromAstSync 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串，
就像vue处理模板一样，把es6代码识别为一段字符串，根据规则转成ast,然后根据映射表转换成es5的语法，然后转成es5字符串，最后转成js


## 4. 前端项目如何找出性能瓶颈

:::details 
<img :src = "$withBase( '/ALEKD/img.png' )" alt = "foo"/>

可参考::

分享一下我近期的经验，之前项目也碰到过用起来很卡的情况，就是用element ui的tab切换组件时，点击tab切换非常卡，非常耗时，在排除了网络请求和js代码执行时间过长等原因后，跑了一次perfermance，结果发现大部分时间都花费在了 DOM GC上了，分析了下原因可能时dom结构太多导致每次tab切换渲染太耗时了。由于我每个tab里面的html结构都一样，都是一个table，只是每次tab切换时请求的数据不一样，我就把table抽离出来了，放到tab组件外面，然后tab里面就空了，就没有那么多dom了，tab切换就不卡了，很流畅。（ps：tab有20-30个切换选项，本人语文水平不行，描述的不清楚，望轻喷。）


:::


## 5. 接口如何防刷

:::details

1：网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求（参考个人博客文章 https://mp.csdn.net/postedit/81672222）

2：源ip请求个数限制。对请求来源的ip请求个数做限制

3：http请求头信息校验；（例如host，User-Agent，Referer）

4：对用户唯一身份uid进行限制和校验。例如基本的长度，组合方式，甚至有效性进行判断。或者uid具有一定的时效性 

5：前后端协议采用二进制方式进行交互或者协议采用签名机制 

6：人机验证，验证码，短信验证码，滑动图片形式，12306形式
:::

## 6. redux 和 vuex 的对比
<img :src = "$withBase( '/ALEKD/img_1.png' )" alt = "foo"/>

## 7. HTTP长连接？短连接？长轮询？短轮询？
<img :src = "$withBase( '/ALEKD/img_2.png' )" alt = "foo"/>


## 8. 简单实现async/await中的async函数
```javascript
function spawn(genF) {
    return new Promise(function(resolve, reject) {
        const gen = genF();
        function step(nextF) {
            let next;
            try {
                next = nextF();
            } catch (e) {
                return reject(e);
            }
            if (next.done) {
                return resolve(next.value);
            }
            Promise.resolve(next.value).then(
                function(v) {
                    step(function() {
                        return gen.next(v);
                    });
                },
                function(e) {
                    step(function() {
                        return gen.throw(e);
                    });
                }
            );
        }
        step(function() {
            return gen.next(undefined);
        });
    });
}
```


## 9. MySQL主从同步是如何实现的 
MySQL主从同步是通过复制实现的，复制是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，复制的工作原理分为以下3个步骤：

- 主服务器（master）把数据更改记录到二进制日志（bin log）中。
- 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。
- 从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。


 复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。


从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。`MySQL4.0`版本之前，从服务器只有1个线程，既负责读取二进制日志，又负责执行二进制日志中的SQL语句。这种方式不符合高性能的要求，目前已淘汰。
<img :src = "$withBase( '/ALEKD/img_3.png' )" alt = "foo"/>


## 10. 

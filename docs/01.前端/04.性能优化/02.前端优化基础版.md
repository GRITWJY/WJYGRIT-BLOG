---
title: 前端优化基础版
date: 2022-06-04 12:46:34
permalink: /pages/KEOMKDW/
categories:
  - 前端
  - 性能优化
tags:
  - 浏览器
  - 优化
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 前端优化基础版
这里的优化主要是针对平时开发中习惯和技巧来展开的

## 加载时优化
### CDN优化
内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间

#### 访问流程

浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。

本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。

本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。

本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。

SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。

浏览器再根据 SLB 发回的地址重定向到缓存服务器。

如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。



#### CDN功能
- **1.静态加速能力。** 通过本地化缓存加速能力给用户提供一个尽力而为的就近访问的高性能访问架构，将用户 访问的内容缓存在边缘节点上，消除由用户地域差异而导致的用户体验不一致，提供不同地区 用户的相对一致的高性能访问体验。
- **2.卸载源站能力。** CDN将资源缓存在它的服务器上，访问是在用户和CDN之间进行的，原来用户的直接请 求都发送到网站服务器上，移交到CDN上后，源站的访问量和带宽占用都会大幅度减小。特 别是对大型网站而言，图片等静态资源占了网站所有请求的90%以上。图片访问量对于大型网 站来说是巨大的，服务器要提供具备相应吞吐能力的服务，其架构设计、运维规划、监控和预 警要十分完善，否则很容易出现稳定性问题。后面将会介绍CDN命中率突然变低，造成源站 出现各种不稳定的问题；也可以看到，CDN的命中率对于减小源站的压力十分关键。总而言之， CDN的存在大大减小了源站的压力，提高了网站的稳定性。
- **3.防攻击能力。** 一般比较成熟的CDN提供商至少有数百个CDN节点，甚至数千个，而把资源放在CDN 上，对网站的恶意攻击大部分都会将目标放到CDN节点上，CDN是一个天然的跨地区甚至跨 洲的大型分布式系统。大量CDN节点的存在，可以有效地将攻击由中心化分散到CDN的边缘 上，从而有效地阻止或者减小攻击造成的危害。
- **4.动态加速能力。** CDN提供静态加速能力的原理是通过将资源缓存在CDN边缘节点上，让用户访问资源的 网络距离变短，从而实现性能的优化。CDN不仅适用于可缓存资源的静态加速，而且可以用于 动态请求的加速，其原理是通过7层路由路径的优选，克服BGP选路的缺点，实现动态加速能 力


## CSS优化
将 CSS 放在文件头部，JavaScript 文件放在底部, 将样式表移到 `<head>` 里会让页面加载地更快。这是因为把样式表移到 `<head>` 里允许页面逐步渲染

- CSS 执行会阻塞渲染，阻止 JS 执行
- JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建

如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。

那为什么 CSS 文件还要放在头部呢？

因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。

另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。
- script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
- async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序
- defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。


CSS：使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。`尽量避免使用@import`它们之间的区别：

- link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
- @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
- style：GUI直接渲染


## webpack 插件

这里有我的几篇 `webpack插件`开发教程，帮助你更好的理解 webpack 是干啥的， 怎么起作用的

注意！！！ `vue.config.js` 中 webpack的插件是 `webpackChain` 中的格式，建议搭建先去看下[中文文档](https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans),
里面有个 `config.toString()` 可以查看 `wepback格式`， 不要直接复制粘贴别人 配置代码， 不然你会懵一两天的。。。。。。。。。我的版本是 6.5.1


- [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack) 对字体文件进行压缩
也有[fontmin客户端](https://ecomfe.github.io/fontmin/#app) 原理就是只保存用到字体
  
- webpack gzip压缩
```javascript
const CompressionWebpackPlugin = require("compression-webpack-plugin");

const compress = new CompressionWebpackPlugin({
  filename: (info) => {
    return `${info.path}.gz${info.query}`;
  },
  algorithm: "gzip",
  threshold: 10240,
  test: new RegExp("\\.(" + ["js"].join("|") + ")$"),
  minRatio: 0.8,
  deleteOriginalAssets: false,
});
```

- image-webpack-loader
```javascript
   config.module
      .rule("images")
      .use("image-webpack-loader")
      .loader("image-webpack-loader")
      .options({
        bypassOnDebug: true, // webpack  'debug' 模式下不执行
      })
      .end()
      .end();
```

- splitChunks
```javascript
    config.optimization.splitChunks({
      // 拆包配置
      chunks: "all", //三选一："initial" 初始化，"all"(默认就是all)，"async"（动态加载）
      minSize: 20000, // 形成一个新代码块最小的体积,只有 >= minSize 的bundle会被拆分出来 30000
      maxSize: 0, //拆分之前最大的数值，默认为0，即不做限制
      minChunks: 1, //引入次数，如果为2 那么一个资源最少被引用两次才可以被拆分出来
      maxAsyncRequests: 5, // 按需加载的最大并行请求数
      maxInitialRequests: 3, // 一个入口最大并行请求数
      cacheGroups: {
        // node_modules模块包
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: "chunk-vendors",
          // name(module) {
          //   const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
          //   return `chunk.${packageName.replace('@', '')}`;
          // },
          chunks: "all",
          priority: -10,
        },
        // UI库单独拆包
        elementUI: {
          name: "chunk-elementUI",
          priority: 20, //  the weight needs to be larger than libs and app or it will be packaged into libs or app
          test: /[\\/]node_modules[\\/]_?element-ui(.*)/,
        },
        // 共享模块
        common: {
          name: "chunk-common",
          minChunks: 2,
          maxSize: 1024, //拆分之前最大的数值，默认为0，即不做限制
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    });
```

- terserJSplugin
```javascript
    config.plugin("TerserJSPlugin").use(TerserJSPlugin, [
      {
        terserOptions: {
          output: {
            comments: false, // 去掉注释
          },
          warnings: false,
          compress: {
            // eslint-disable-next-line camelcase
            drop_console: true,
            // eslint-disable-next-line camelcase
            drop_debugger: true,
            // pure_funcs: ['console.log'] // 移除console
          },
        },
      },
    ]);

```



## 缓存

- 对静态组件：通过设置 Expires 头部来实现永不过期策略。
- 对动态组件：用合适的 Cache-Control 头部来帮助浏览器进行有条件性的请求。


在常用的缓存是 Cache-control
```shell
nginx:
location ~ .*\.(css|js|swf|php|htm|html )$ {
  add_header Cache-Control no-store;
}
```

对于站点中不经常修改的静态内容（如图片，JS，CSS），可以在服务器中设置expires过期时间，控制浏览器缓存，达到有效减小带宽流量，降低服务器压力的目的。
```shell
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {
  #过期时间为30天，
  #图片文件不怎么更新，过期可以设大一点，
  #如果频繁更新，则可以设置得小一点。
  expires 30d;
}
location ~ .*\.(js|css)$ {
  expires 10d;
}
```
Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。


**Cache-control策略**
Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。

**http协议头Cache-Control ：**

值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age

各个消息中的指令含义如下：

- Public指示响应可被任何缓存区缓存。
- Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
- no-cache指示请求或响应消息不能缓存
- no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
- max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
- min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
- max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。


**Last-Modified/If-Modified-Since**


- Last-Modified/If-Modified-Since要配合Cache-Control使用。
- Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
- If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。



### 强制缓存
   <img :src="$withBase('/keomkdw/img.png')" alt="foo"/>

   <img :src="$withBase('/keomkdw/img1.png')" alt="foo"/>

##### 协商缓存(对比缓存)
是一种服务端缓存策略。主要是资源有个标识，用来检查缓存与最新版本是否相同，用于网站更新

   <img :src="$withBase('/keomkdw/img2.png')" alt="foo"/>

   <img :src="$withBase('/keomkdw/img3.png')" alt="foo"/>


#### 协商缓存中的标识
- last-midified: 资源上一次修改的时间

    <img :src="$withBase('/keomkdw/img4.png')" alt="foo"/>

    <img :src="$withBase('/keomkdw/img5.png')" alt="foo"/>


- etag：资源对应的唯一字符串

    <img :src="$withBase('/keomkdw/img6.png')" alt="foo"/>

    <img :src="$withBase('/keomkdw/img7.png')" alt="foo"/>


#### 总结
- 首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存
- 如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 If-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：
  - 若资源更新，那么返回资源和 200 状态码
  - 如果资源未更新，那么告诉浏览器直接使用缓存获取资源


<img :src="$withBase('/keomkdw/img8.png')" alt="foo"/>



## 使用外部JS和CSS

JavaScript 和 CSS 是应该包含在外部文件还是内联在页面里？

实际上，`使用外部文件一般可以让页面加载更快，因为 JS 和 CSS 文件会被浏览器缓存。` `而内联的 JavaScript 和CSS 在每次 HTML 文档下载时都被下载。`虽然内联减少了http请求，但增加了HTML文档大小。另一方面，如果 JavaScript 和 CSS 被缓存了，那么 HTML 文档可以减小大小而不增加 HTTP 请求。

核心因素就是 JavaScript 和 CSS 被缓存相对于 HTML 文档被请求的频率。如果网站用户每个会话打开了多个页面，许多页面重复使用相同的 JavaScript 和CSS，那么有很大可能用外部 JS 和 CSS 更好。


## 用智能的事件处理器

有时候页面看起来响应速度比较慢，是因为绑定到不同元素的大量事件处理函数执行太多次。一种更好的解决方法就是使用事件委托。另外，不必等到 `onload` 事件来开始处理 DOM 树，使用`DOMContentLoaded` 会更快。大多时候需要的只是想访问的元素已在 DOM 树中，所以不必等到所有图片下载完。

- `onLoad`是的在页面所有文件加载完成后执行；
- `DomContentLoad`是Dom加载完成后执行，不必等待样式脚本和图片加载。


## 运行时优化

### 回流与重绘
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。 下面这些操作会导致回流：

- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类, 如: hover
- 设置style属性
- 添加或者删除可见的DOM元素
- 计算 `offsetWidth / offsetHeight`

当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。

-color、background 相关属性：background-color、background-image 等
-outline 相关属性：outline-color、outline-width 、text-decoration
-border-radius、visibility、box-shadow
-display是dom级别的，可以渲染和重绘。 visiblity不是dom级别的，不能重绘，只能渲染

### 提取第三方库
由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。


### 图片懒加载
这个其实 [elementui 里的 image 组件](https://element.eleme.cn/#/zh-CN/component/image) 就可以达到要求了

如果想看原理，可以看我的这边博客[图片懒加载](http://www.wjygrit.cn/pages/RLWMCP)


### 渲染优化
这个可以看我的 [前端渲染大量数据](http://www.wjygrit.cn/pages/keqos3k2/#%E6%9C%80%E7%B2%97%E6%9A%B4%E7%9A%84%E5%81%9A%E6%B3%95-%E4%B8%80%E6%AC%A1%E6%80%A7%E6%B8%B2%E6%9F%93)




- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327/answer/193768864)
- [CDN原理解析](https://juejin.cn/post/6844903873518239752)
- [使用JS添加交互](https://web.dev/critical-rendering-path-adding-interactivity-with-javascript/)
- [webpackChain配置](https://github.com/Yatoo2018/webpack-chain/tree/zh-cmn-Hans)
- [每个前端都必须要学会的Webpack优化手段](https://juejin.cn/post/7083519723484708878#heading-11)
- [Vue项目优化打包——前端加分项](https://juejin.cn/post/7004045635620405278)
- [我用webpack把公司的老项目做了下优化](https://juejin.cn/post/7072012773730811941#heading-8)
- [前端缓存最佳实践](https://juejin.cn/post/6844903737538920462)
- [彻底弄懂前端缓存](https://juejin.cn/post/7052527032491573279#heading-5)
- [(建议收藏)为什么第二次打开页面快？五步吃透前端缓存，让页面飞起](https://juejin.cn/post/6993358764481085453#heading-10)
- [Nginx代理缓存机制](https://juejin.cn/post/7036281834728554533)
- [前端项目常规性能规划](https://juejin.cn/post/7080066104613142559#heading-2)

---
title: 从输入url到网页出现发生了什么
date: 2022-06-04 10:26:34
permalink: /pages/kaoenfk/
categories:
  - 前端
  - 性能优化
tags:
  - 优化
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 从输入url到网页出现发生了什么

在性能优化中，我会先分析 `从输入url到网页显现` 这一过程中的每个阶段，之后的优化将会按照每个阶段进行分析。

<img :src="$withBase('/kaoenfk/img.png')" alt='foo'/>


## 1、DNS Lookup

浏览器解析域名拿到对应的IP地址后，才能和服务器进行通信。

DNS服务器的层次结构包括 
- 根域名服务器
- 顶级域名服务器， 如.com/.net/
- 权威服务器

还有一个Local DNS, 用户上网需要通过ISP的网络接入互联网， ISP 会分配给用户一个DNS服务器，这个DNS代理域名解析请求给
最终权威的DNS， 它具有cache能力，如果Local DNS 在 TTL 时间内有cache， 不会迭代向根域、顶级域、和权威域发送DNS

### 递归查询、迭代查询
这里根据这张图来进行解说，图中 主机 `cse.nyu.edu` 想要获取 主机`gaia.cs.umass.edu` 的
<img :src="$withBase('/kaoenfk/img2.jpg')" alt='foo'/>

1、 首先， 主机 `cse.nyu.edu` 向它的 `本地DNS服务器: dns.nyu.edu` 发送一个DNS查询报文，  该报文包括 被转换的主机名`gaia.cs.umass.edu`

2、 `本地DNS服务器`将报文转发到 `根DNS服务器`

3、 `根DNS服务器` 注意到 `.edu前缀`， 并向`本地DNS服务器`返回 `负责.edu的TLD的IP地址列表`。 意识是： 我不知道它的IP地址，但这些TLD可能知道

4、 `本地DNS服务器` 向这些`TLD服务器之一`发送查询报文

5、 该TLD服务器 注意到 `umass.edu前缀`， 并返回 `权威服务器的IP地址：dns.umass.edu`

6、 最后，本地服务器向 `dns.umass.edu`发送查询报文， `dns.umass.edu` 就用 `gaia.cs.umass.edu` 的IP地址进行响应

其中`递归查询`是 `主机cse.nyu.edu` 向 `dns.nyu.edu` 发出的查询， 因为这是 自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机

而后继的三个查询是`迭代查询`，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。

### DNS缓存

在一个 DNS 查询的过程中，当某一台 DNS 服务器接收到一个 DNS 应答（例如，包含某主机名到 IP 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存里的内容。当然，缓存并不是永久的，每一条映射记录都有一个对应的生存时间，一旦过了生存时间，这条记录就应该从缓存移出。

事实上，有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器，需要向根 DNS 服务器发起查询的请求很少。


到这里，DNS的基本流程就已经了解清楚了， 在这部分也可以优化， 不过这个就留到之后做的项目大到需要优化的时候吧


## 2、建立TCP连接
这部分我以TCP的三次握手和四次挥手的流程来讲

<img :src="$withBase('/kaoenfk/img3.png')" alt='foo'/>

先看下`TCP的头部`， 这里只把需要关注的标注出来了, 对于三次握手和四次挥手，我们需要关注的就是 TCP 的头部`序列号、确认号以及几个标记为 SYN/FIN/ACK/RST`
- **序列号：** 在初次建立连接的时候，客户端和服务端都会为「本次的连接」随机初始化一个序列号。（纵观整个TCP流程中，序列号可以用来解决网络包乱序的问题）
- **确认号：** 该字段表示「接收端」告诉「发送端」对上一个数据包已经成功接收（确认号可以⽤来解决网络包丢失的问题）
- 而**标记位**就很好理解啦。SYN为1时，表示希望创建连接。ACK为1时，确认号字段有效。FIN为1时，表示希望断开连接。RST为1时，表示TCP连接出现异常，需要断开。

### 三次握手

**三次握手的过程其实就是在： 确认通信双方的序列号**

- **初始化：** 客户端和服务端都处于 CLOSE 状态， 服务器主动监听某个端口，处于 LISTEN 状态
- **客户端的第一次握手：** 客户端会随机生成出序列号（这里的序列号一般叫做client_isn），并且把标志位设置为SYN（意味着要连接），然后把该报文发送给服务端，客户端发送完成后自己进入 `SYN_SEND`状态
  
<img :src="$withBase('/kaoenfk/img3.png')" alt='foo'/>

- 服务端接收到了客户端的请求之后，自己也初始化对应的序列号（这里的序列号一般叫做 server_isn）
- 在「确认号」字段里填上client_isn + 1（相当于告诉客户端，已经收到了发送过来的序列号了） ，并且把 SYN 和 ACK 标记位都点亮(置为1)
- 把该报文发送客户端，服务端的状态变成 SYN-REVD 状态


<img :src="$withBase('/kaoenfk/img5.png')" alt='foo'/>


- 客户端收到服务端发送的报文后，就知道服务端已经接收到了自己的序列号（通过确认号就可以知道），并且接收到了服务端的序列号(server_isn)
- 此时，客户端需要告诉服务端自己已经接收到了他发送过来的序列号，所以在「确认号」字段上填上server_isn+1，，并且标记位 ACK 为1


<img :src="$withBase('/kaoenfk/img6.png')" alt='foo'/>


- 客户端在发送报文之后，进入 ESTABLISHED 状态，而服务端接收到客户端的报文之后，也进入 ESTABLISHED 状态
- 这就是三次握手的过程以及涉及到的TCP状态
- 总结下来，就是双方都把自身的序列号发给对方，看对方能不能接收到。如果「确认可以」，那就可以正常通信。（三次握手这个过程就可以看到双方都有接收和发送的能力）

问题：

**1、 两次握手行吗？** 两次握手只能保证客户端的序列号成功被服务端接收，而服务端是无法确认自己的序列号是否被客户端成功接收。所以是不行的


**2.序列号为什么是随机的？以及序列号是怎么生成的？**

先看个正常的场景，其中C假冒A给B通信
<img :src="$withBase('/kaoenfk/img7.png')" alt='foo'/>

由于ISN是随机的， B响应后， 就不知道 ISN_B， 最终则直接终止连接。

若不是随机的，C能推出ISN_B， 那么它就可以模拟一个ACK，最终建立通信

总结来说，一方面为了安全性（随机ISN能避免非同一网络的攻击），另一方面可以让通信双方能够根据序号将「不属于」本连接的报文段丢弃

<img :src="$withBase('/kaoenfk/img8.png')" alt='foo'/>


**3.既然网络是不可靠的，那建立连接不是会经过三次握手吗？那要是在中途丢了，怎么办？**

**假设第一个包丢了，** 客户端发送给服务端的 SYN 包丢了（简而要之就是服务端没接收到客户端的SYN包） ,客户端迟迟收不到服务端的ACK包，那会周期性超时重传，直到收到服务端的ACK

**假设第二个包丢了，** 服务端发送的SYN+ACK包丢了（简而要之就是客户端没接收到服务端的SYN+ACK包） , 服务端迟迟收不到客户端的ACK包，那会周期性超时重传，直到收到客户端的ACK

**假设第三个包丢了（ACK包）**，客户端发送完第三个包后单方面进入了 ESTABLISHED 状态，而服务端也认为此时连接是正常的，但第三个包没到达服务端
  - 一、如果此时客户端与服务端都还没数据发送，那服务端会认为自己发送的SYN+ACK的包没发送至客户端，所以会超时重传自己的SYN+ACK包
  - 二、如果这时候客户端已经要发送数据了，服务端接收到了ACK + Data数据包，那自然就切换到 ESTABLISHED 状态下，并且接收客户端的Data数据包
  - 三、如果此时服务端要发送数据了，但发送不了，会一直周期性超时重传SYN + ACK，直到接收到客户端的ACK包


### 四次挥手
以客户端主动断开为例

客户端会发送`FIN报文`给服务端， 客户端发送完毕后，就进入`FIN_WAIT_1`状态

服务端接收到`FIN报文`后，回复 `ACK报文`给客户端， 服务端发送完之后，就进入 `CLOSE_WAIT`状态

客户端接收到服务端的`ACK报文`后， 就进入 `FIN_WAIT_2`状态

<img :src="$withBase('/kaoenfk/img9.png')" alt='foo'/>


这时候，服务器可能还有数据要发送给客户端，等服务端确认自己已经 `没有数据返回给客户端之后` ，就发送 `FIN报文给客户端`了，自己进入 `LAST_ACK 状态`

客户端收到服务端的`FIN报文`之后，回应`ACK报文`，自己进入 `TIME_WAIT 状态`

服务端收到客户端的`ACK报文`之后，服务端就进入 `CLOSE 状态`

客户端在`TIME_WAIT等到2MSL`，也进入了 `CLOSE 状态`

<img :src="$withBase('/kaoenfk/img10.png')" alt='foo'/>


**问题**

**1.为什么是四次呢**

其实很好理解，当客户端第一次发送 FIN 报文之后，只是代表着客户端不再发送数据给服务端，但此时客户端还是有接收数据的能力的。而服务端收到FIN报文的时候，可能还有数据要传输给客户端，所以只能先回复 ACK给客户端

等到服务端不再有数据发送给客户端时，才发送 FIN 报文给客户端，表示可以关闭了。

所以，一来一回就四次了。

**2.从四次挥手的流程上来看，有个 TIME_WAIT 状态，你知道这个状态干什么用的吗？（等待 2MSL）**

主要有两个原因吧。1.保证最后的 ACK 报文 「接收方」一定能收到（如果收不到，对方会 重发 FIN 报文）2. 确保在创建新连接时，先前网络中残余的数据都丢失了

其实也比较好理解的。就正如我们重启服务器一样，会先优雅关闭各种资源，再留有一段时间，希望在这段时间内，资源是正常关闭的，这样重启服务器（或者发布）就基本认为不会影响到线上运行了。


**3.假设 TIME_WAIT 状态多过会有什么危害？怎么解决呢？**

主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留两倍的MSL时长

在socket的TIME_WAIT状态结束之前，该socket所占用的本地端口号将一直无法释放。这也是文章开头的提到问题的一个原因之一。

在高并发（每秒几万qps）并且采用短连接方式进行交互的系统中运行一段时间后，系统中就会存在大量的time_wait状态，如果time_wait状态把系统所有可用端口 都占完了且尚未被系统回收时，就会出现无法向服务端创建新的socket连接的情况。此时系统几乎停转，任何链接都不能建立。


**4.TCP连接，那这个连接到底是什么？你是怎么理解的？**

该连接是一条逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。前面讲过，由于TCP协议只在端系统中运行，而不在
中间的网络元素中运行，所以中间网络元素是不会维持TCP连接状态。

## 3.浏览器
这部分只做简单概述，这里有一篇关于浏览器的详细描述，需要了解核心原理的可以看这篇文章
服务器返回HTTP Response后， 浏览器陆续开始接收数据，进行HTML下载、解析、渲染显示等过程。具体步骤如下
- 1、 如果是Gzip包，则先解压
- 2、 解析HTML的头部代码，下载头部代码中引用的样式资源文件或者脚本文件
- 3、 解析HTML代码和样式文件代码， 这个过程会构造出两个树结构，即与HTML相关的DOM树，以及与CSS相关的CSSOM树。
- 4、 通过遍历DOM树和CSSOM树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造出渲染树
- 5、 根据渲染树完成绘制过程
  
<img :src="$withBase('/kaoenfk/img10.png')" alt='foo'/>

浏览器下载HTL后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构造DOM树，同时进行样式下载。
DOM树构建完成后，立即开始构造CSSOM树。如果样式表的下载速度够快，DOM树和CSSOM树就会进入一个并行进程，
当两颗树准备完毕，即可开始构造渲染树，最后进行绘制。

而在真实页面解析过程中，浏览器通常会因为各种因素被阻断

- 1、 HTML代码中的JS代码会阻断DOM树的构造，因为浏览器认为这段JS代码可能会修改DOM结果，所以必须等待JS代码执行完毕，再恢复DOM树的构造过程。这是由浏览器的安全解析策略决定的，目前并没有指定某个JS代码不涉及DOM的属性
- 2、 浏览器必须等待样式表加载完成，才能开始构建CSSOM树
- 3、 还有一种特殊情况，浏览器在解析HTML时遇到JS代码，而此时CSSOM树还未构建完成，则浏览器会暂停脚本执行(浏览器同时也会暂停继续向下解析HTML代码，从而导致DOM树的构建过程被暂停阻塞)，直到CSS样式文件下载完成，并完成CSSOM树的构建，才会重新恢复原来的解析。这是由浏览器的安全解析策略决定的


通过对上面因素的分析，我们可以发现，HTML中的内联JS代码执行的危害之处，不在于它阻断了DOM树的构建过程，除非是一段特别恶劣的JS代码运行非常慢，通常内联的JS代码运行大概
消耗十几毫秒，也就是暂停构建几毫秒到几十毫秒。 它最大的危害在于第三种情况，即DOM树构建被阻塞的时间不只是JS代码运行的时间，而是会加上样式资源文件下载和CSSOM树的构建时间，
这时浏览器所进行的串行解析过程，与我们在前面期望的DOM树和CSSOM树的并行解析过程相差甚远

<img :src="$withBase('/kaoenfk/img13.png')" alt='foo'/>



## 参考资料
- [TCP进行通信时的初始序列号为什么是随机的](https://blog.csdn.net/qq_42950328/article/details/111477158)
- [为什么TCP的初始序列号ISN是随机生成的？](https://blog.csdn.net/weixin_44164489/article/details/108538996)
- [面试官问我TCP三次握手和四次挥手，我真的是](https://juejin.cn/post/7045059219216662564)
- https://web.dev/critical-rendering-path-analyzing-crp/
- [浏览器工作原理](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)
- [浏览器如何工作的](http://taligarsiel.com/Projects/howbrowserswork1.htm)
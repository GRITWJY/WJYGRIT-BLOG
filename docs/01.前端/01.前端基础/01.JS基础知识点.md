---
title: JS基础及小tip
date: 2022-05-01 09:51:37
permalink: /pages/a61298/
categories:
  - 前端
  - 前端基础  
tags:
  - JS
author: WJYGRIT
---

# JS基础篇
JS是一门用来与网页交互的脚本语言，包含以下三个组成部分。
- ECMAScript: 由ECMA-262定义并提供核心功能
- 文档对象模型(DOM):提供与网页内容交互的方法和接口
- 浏览器对象模型(BOM): 提供与浏览器交互的方法和接口

## 1、 script元素
- async:表示**应该立即开始下载脚本，但不能阻止其他页面动作**，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
- charset：可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
- crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。`crossorigin="anonymous"`配置文件请求不必设置凭据标志。`crossorigin="use-credentials"`设置凭据标志，意味着出站请求会包含凭据。
- defer：可选。**表示脚本可以延迟到文档完全被解析和显示之后再执行**。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
- integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI, Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN, Content Delivery Network）不会提供恶意内容。
- src：
- type

- 1、 async/defer的区别：`defer`被称作**推迟脚本执行**，先下载，最后再执行；`async`:异步脚本执行


##  2、use strict是什么意思 ? 使用它区别是什么？
use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：

- 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
- 消除代码运行的不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的 Javascript 做好铺垫。

区别：

- 禁止使用 with 语句。
- 禁止 this 关键字指向全局对象。
- 对象不能有重名的属性。

## 3、 let中要注意的一些事情
<h3>暂时性死区</h3>

let与var的另一个重要的区别，就是let声明的变量不会在作用域中被提升。
```javascript
console.log(name); // undefined
var name = 'Matt'
console.log(age); // ReferenceError:age没有定义
let age = 25
```
在解析代码时，JavaScript引擎也会注意出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出ReferenceError。

<h3>全局声明</h3>

与var关键字不同，**_使用let在全局作用域中声明的变量不会成为window对象的属性_**（var声明的变量则会）。
```javascript
var name = 'Matt';
console.log(window.name); // matt
let age = 26
console.log(window.age); // undefined
```
不过，let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免SyntaxError，必须确保页面不会重复声明同一个变量。

<h3>条件声明</h3>
let声明的作用域仅限于该块。

<h3>let声明的作用域仅限于该块。</h3>
而在使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个setTimeout引用的都是不同的变量实例，所以console.log输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。

## 4、 数据类型
ECMAScript有6种简单数据类型(**原始类型**)：Undefined,Null,Boolean,Number,String,Boolean。Symbol是ECMAScript6新增的。还有Object

<h3>typeof操作符</h3>
对一个值使用typeof操作符会返回下列字符串之一：
- ❑ "undefined"表示值未定义；
- ❑ "boolean"表示值为布尔值；
- ❑ "string"表示值为字符串；
- ❑ "number"表示值为数值；
- ❑ "object"表示值为对象（而不是函数）或null；
- ❑ "function"表示值为函数；
- ❑ "symbol"表示值为符号。

<h3>Boolean转换</h3>
<img :src="$withBase('/css/img_13.png')" alt="foo"/>

<h3>数值转换</h3>
<img :src="$withBase('/css/img_14.png')" alt="foo"/>
<img :src="$withBase('/css/img_15.png')" alt="foo"/>
<img :src="$withBase('/css/img_16.png')" alt="foo"/>
<img :src="$withBase('/css/img_17.png')" alt="foo"/>
<img :src="$withBase('/css/img_18.png')" alt="foo"/>


## 5、 操作符

<h3>`~~`</h3>
~~其实是一种利用符自号进行的类型转换,转换成数字类型

```javascript
~~true == 1
~~false == 0
~~"" == 0
~~[] == 0
~~undefined ==0
~~!undefined == 1
~~null == 0
~~!null == 1
```

<h3>布尔操作符</h3>
**`逻辑非！`**
- ❑ 如果操作数是**对象**，则返回false。
- ❑ 如果操作数是**空字符串**，则返回true。
- ❑ 如果操作数是**非空字符串**，则返回false。
- ❑ 如果操作数是**数值0**，则返回true。
- ❑ 如果操作数是**非0数值（包括Infinity**），则返回false。
- ❑ 如果操作数是**null**，则返回true。
- ❑ 如果操作数是**NaN**，则返回true。
- ❑ 如果操作数是**undefined**，则返回true。

**`逻辑与 &&`**
- ❑ 如果第一个操作数是对象，则返回第二个操作数。
- ❑ 如果第二个操作数是对象，则只有第一个操作数求值为true才会返回该对象。
- ❑ 如果两个操作数都是对象，则返回第二个操作数。
- ❑ 如果有一个操作数是null，则返回null。
- ❑ 如果有一个操作数是NaN，则返回NaN。
- ❑ 如果有一个操作数是undefined，则返回undefined。

**`逻辑或 ||`**
- ❑ 如果第一个操作数是对象，则返回第一个操作数。
- ❑ 如果第一个操作数求值为false，则返回第二个操作数。
- ❑ 如果两个操作数都是null，则返回null。
- ❑ 如果两个操作数都是对象，则返回第一个操作数。
- ❑ 如果两个操作数都是NaN，则返回NaN。
- ❑ 如果两个操作数都是undefined，则返回undefined。

<h3>相等操作符</h3>
在转换操作数的类型时，相等和不相等操作符遵循如下规则。

- ❑ 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false转换为0, true转换为1。
- ❑ 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。
- ❑ 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法取得其原始值，再根据前面的规则进行比较。
- ❑ 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。

在进行比较时，这两个操作符会遵循如下规则。
- ❑ null和undefined相等。
- ❑ null和undefined不能转换为其他类型的值再进行比较。
- ❑ 如果有任一操作数是NaN，则相等操作符返回false，不相等操作符返回true。记住：即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，NaN不等于NaN。
- ❑ 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true。否则，两者不相等。

<img :src="$withBase('/css/img_19.png')" alt="foo"/>


## 6、 with语句
with语句的用途是将代码作用域设置为特定的对象，其语法是：
`with(expression) statement;`
使用with语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能够提供便利，可以看下面两段代码
```javascript
let qs = location.search.substring(1);
let hostName = location.hostname;
let url = location.href;

with (location) {
  let qs = search.substring(1)
  let hostName = hostname
  let url = href
}
```
这里，with语句用于连接location对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索location对象，看 它是否有一个同名的属性。如果有，则该变量会被求值为location对象的属性。严格模式不允许使用with语句，否则会抛出错误。

:::danger
由于with语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用with语句。
:::

## 7、垃圾回收
### 标记清理

JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。**标记过程的实现并不重要，关键是策略。**

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。**然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了**，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。


### 引用计数
另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是**对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1**。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。

**问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。**
















































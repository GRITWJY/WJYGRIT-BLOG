---
title: 树相关题目  
date: 2022-06-15 09:02:34  
permalink: /pages/akjfifvfanfj/  
categories:
    - 算法
    - LC刷题日记
tags:
    - 算法
    - 树
author:  
    name: WJYGRIT   
    link: https://github.com/GRITWJY  
---

# 树相关题目

## 恢复二叉搜索树

:::: tabs :options="{ useUrlFragment: false }"

::: tab 题目描述
<img :src="$withBase('/akjfifvfanfj/img.png')" alt='foo'/>

<img :src="$withBase('/akjfifvfanfj/img_1.png')" alt='foo'/>

:::


::: tab 方法一:显示中序遍历

<img :src="$withBase('/akjfifvfanfj/img_2.png')" alt='foo'/>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void inorder(TreeNode* root, vector<int>& nums){

        if(root == nullptr){
            return;
        }
        inorder(root->left, nums);
        nums.push_back(root->val);
        inorder(root->right, nums);
    }

    pair<int,int> findTwoSwapped(vector<int>& nums){
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for(int i = 0; i < n - 1; ++i) {
            if(nums[i+1] < nums[i]) {
                index2 = i + 1;
                if(index1 == -1) {
                    index1 = i;
                } else {
                    break;
                }
            }
        }

        int x = nums[index1], y = nums[index2];
        return {x, y};
    }


    void recover(TreeNode* r, int x, int y, int count) {
        if(r != nullptr) {
            if(r->val == x || r->val == y) {
                r->val = r->val == x ? y : x;
                if(--count == 0) {
                    return;
                }
            }

            recover(r->left, x, y, count);
            recover(r->right, x, y, count);
        }
    }

    void recoverTree(TreeNode* root) {
       vector<int> nums;
       inorder(root, nums);
       pair<int,int> swapped = findTwoSwapped(nums);
       recover(root, swapped.first, swapped.second, 2);
    }
};

```

<img :src="$withBase('/akjfifvfanfj/img_3.png')" alt='foo'/>


:::


::: tab 隐式中序遍历

<img :src="$withBase('/akjfifvfanfj/img_4.png')" alt='foo'/>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
       stack<TreeNode*> stk;
       TreeNode* x = nullptr;
       TreeNode* y = nullptr;
       TreeNode* pred = nullptr;

        while(!stk.empty() || root != nullptr) {
            while(root != nullptr) {
                stk.push(root);
                root = root->left;
            }

            root = stk.top();
            stk.pop();
            if(pred != nullptr && pred->val > root->val) {
                y = root;
                if(x==nullptr) {
                    x = pred;
                } else {
                    break;
                }
            }

            pred = root;
            root = root->right;
        }
        swap(x->val, y->val);

    }
};

```

<img :src="$withBase('/akjfifvfanfj/img_6.png')" alt='foo'/>

:::


::: tab morris
<img :src="$withBase('/akjfifvfanfj/img_5.png')" alt='foo'/>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */


class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *x = nullptr, *y = nullptr, *pred = nullptr, *predecessor = nullptr;

        while(root != nullptr) {
            if(root->left != nullptr) {
                predecessor = root->left;
                while(predecessor->right != nullptr && predecessor->right != root) {
                    predecessor = predecessor->right;
                }

                if(predecessor->right == nullptr) {
                    predecessor->right = root;
                    root = root->left;
                } else {
                    if(pred != nullptr && pred->val > root->val) {
                        y = root;
                        if(x == nullptr) {
                            x = pred;
                        }
                    }
                    pred = root;
                    predecessor->right = nullptr;
                    root = root->right;
                }

            } else {
                if(pred != nullptr && pred->val > root->val) {
                    y = root;
                    if(x == nullptr) {
                        x = pred;
                    }
                }
                pred = root;
                root = root->right;
            }
        }
         swap(x->val, y->val);
    }
};

```

:::

::::




## 二叉树的锯齿形层序遍历
:::: tabs :options="{ useUrlFragment: false }"
::: tab 题目描述
<img :src="$withBase('/akjfifvfanfj/img_7.png')" alt='foo'/>
:::

::: tab 题解

<img :src="$withBase('/akjfifvfanfj/img_8.png')" alt='foo'/>

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ans;

        queue<TreeNode*> nodeQueue;
        bool isOrderLeft = true;
        nodeQueue.push(root);

        while(!nodeQueue.empty()) {
            deque<int> levelList;
            int size = nodeQueue.size();
            for(int i = 0; i < size; i++) {
                auto node = nodeQueue.front();
                nodeQueue.pop();
                if(isOrderLeft) {
                    levelList.push_back(node->val);
                } else {
                    levelList.push_front(node->val);
                }

                if(node->left) {
                    nodeQueue.push(node->left);
                } 
                if(node->right) {
                    nodeQueue.push(node->right);
                }        
            }
            ans.emplace_back(vector<int>{levelList.begin(), levelList.end()});
            isOrderLeft = !isOrderLeft;
        }
        return ans;
    }
};
```

:::

::::



## 二叉树的层序遍历 II
:::: tabs :options="{ useUrlFragment: false }"

::: tab 题目描述

<img :src="$withBase('/akjfifvfanfj/img_9.png')" alt='foo'/>

:::


::: tab 题解
/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode() : val(0), left(nullptr), right(nullptr) {}
*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
* };
  */
  class Solution {
  public:
  vector<vector<int>> levelOrderBottom(TreeNode* root) {
  auto levelOrder = vector<vector<int>>();

       queue<TreeNode*> nodeQueue;
       nodeQueue.push(root);
       while(!nodeQueue.empty()) {
           auto level = vector<int>();
           int n = nodeQueue.size();
           for(int i=0;i<n;i++){
               auto node = nodeQueue.front();
               nodeQueue.pop();
               level.push_back(node->val);
               if(node->left) {
                   nodeQueue.push(node->left);
               }
               if(node->right) {
                   nodeQueue.push(node->right);
               }
           }
           levelOrder.push_back(level);
       }

       reverse(levelOrder.begin(), levelOrder.end());
       return levelOrder;
  }
  };
:::

::::




---
title: 01.最长回文子串
date: 2022-06-01 18:13:34
permalink: /pages/KEMAWL/
categories:
  - 算法
  - 字符串
tags:
  - 字符串
  - 动态规划
author:
  name: WJYGRIT
  link: https://github.com/GRITWJY
---

# 01.最长回文子串

## 题目描述

给你一个字符串 s，找到 s 中最长的回文子串。

:::: tabs :options="{ useUrlFragment: false }"
::: tab 提示 id="first"
- 1 <= s.length <= 1000
- **s 仅由数字和英文字母组成**
  :::


::: tab "示例1"
```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```
:::

::: tab 示例2
```
输入：s = "cbbd"
输出："bb"
```
:::
::::


## 中心扩散法

- 枚举所有可能的回文子串的中心位置
- 中心位置可能是一个字符，也有可能是两个相邻字符

这里的情况是，从子串长度为 1 或 2 开始， 每次不断向两边扩展，如果两边的字母相同，可以继续扩展。

我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。

:::: tabs :options="{ useUrlFragment: false }"
::: tab java
```java
class Solution {
  public String longestPalindrome(String s) {
    if(s == null || s.length() < 1) {
       return "";
    }
    // 从字符串的第1个字符开始遍历
    for(int i = 0; i < s.length(); i++){
      // 分别计算出 初始长度 为 1 的 和 2 的长度值
      int len1 = expandAroundCenter(s, i, i);
      int len2 = expandAroundCenter(s, i, i + 1);
      int len = Math.max(len1, len2);
      if(len > end - start) {
        start = i - (len - 1) / 2; // 记录起始地
        end = i + len / 2;
      }
    }
    return s.substring(start, end + 1)
  }  
  
  public int expandAroundCenter(String s, int left, int right) {
    while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
      --left;
      --right;
    }
    return right - left - 1;
  }
}
```
:::


::: tab javascript
```javascript
function longestPalindrome(s) {
  if (s == null || s == "") {
    return "";
  }

  let start = 0;
  let end = 0;
  for (let i = 0; i < s.length; i++) {
    let len1 = expandAroundCenter(s, i, i);
    let len2 = expandAroundCenter(s, i, i + 1);
    let len = Math.max(len1, len2);
    if (len > end - start) {
      start = i - Math.floor((len - 1) / 2);
      end = i + Math.floor(len / 2);
    }
  }
  return s.substring(start, end + 1);
}

function expandAroundCenter(s, left, right) {
  while (
    left >= 0 &&
    right < s.length &&
    s.charCodeAt(left) === s.charCodeAt(right)
  ) {
    --left;
    ++right;
  }
  return right - left - 1;
}
```
:::

::: tab cpp
```cpp
// 技巧： 
// 返回值需要获取两个值时 可以用pair<int, int>, 结果用 {} 包裹
// auto .auto的原理是通过后面的值来推断变量类型，因此后面的值必须存在且类型明确，即auto变量必须被正确地初始化；
// 2.auto并非单独的类型，其不能用于类型转换等操作；
// 3.auto序列的多个变量必须为同一类型。

class Solution {
  public:
    pair<int, int> expandAroundCenter(const string& s, int left, int right) {
      // 这里是多减了一次
      while(left >= 0 && right < s.size() && s[left] == s[right]) {
        --left;
        ++right;
      }
      return {left + 1, right - 1};
    }
    
    string longestPalindrome(string s) {
      int start = 0, end = 0;
      for(int i = 0; i< s.size(); i++) {
        auto [left1, right1] = expandAroundCenter(s, i, i);
        auto [left2, right2] = expandAroundCenter(s, i, i + 1);
        if (right1 - left1 > end - start) {
          start = left1;
          end = right1;
        }
        if (right2 - left2 > end - start){ 
          start = left2;
          end = right2;
        }
        return s.substr(start, end - start + 1);
      }
    }
}
```
:::
::::


## 动态规划

中心扩散是从小到大， 那么动态规划就是从大到小了， 一个回文串去掉首位后仍然是回文串

`p(i,j) = p(i+1,j-1) ^ (si === sj)`

接下来就是怎么进行过程的计算

- 首先边界条件 `(j-1) - (i+1) < 2`, 即 s[i,j] 长度为2或3，不用检查是否是回文 ,j-i<3

- 得到一个状态值为 true 的时候， 记录其实位置和长度，填完表以后再截取

- 状态转义方程： `dp[i][j] = (s[i] === s[j]) && (j - i < 3 || dp[i+1][j-1])`

- 因为参考的是左下角的值， 就只能升序填列，再升序填行

:::: tabs :options="{ useUrlFragment: false }"
::: tab java
```java 

/* 知识点：
1. s.toCharArray 转为字符数组
*/

public class Solution {
  public String longestPalindrome(String s) {
    int len = s.length();
    if(len < 2) {
      return s;
    }
    int maxLen = 1;
    int begin = 0;
    boolean dp[][] dp = new boolean[len][len];
    
    char[] charArray = s.toCharArray();
    // 左下角先填， 先升序填列
    for(int j = 1; j < len; j++) {
      // 再升序填行
      for(int i = 0; i < j; i++) {
        if(charArray[i] != charArray[j]) {
          dp[i][j] = false;
        } else {
          if(j - i < 3) {
            dp[i][j] = true;
          } else {
            dp[i][j] = dp[i + 1][j - 1];
          }
        }
        if(dp[i][j] && j - i + 1 > maxLen) {
          maxLen = j - i + 1;
          begin = i;
        }
      }
    }
    return s.substring(begin, begin + maxLen);
  }
}
```
:::


::: tab javascript
```javascript
function longestPalindrome2(s) {
  let len = s.length;
  if (len < 2) {
    return s;
  }

  let maxLen = 1;
  let begin = 0;
  let dp = Array.from(Array(len), () => new Array(len));

  for (let j = 1; j < len; j++) {
    for (let i = 0; i < j; i++) {
      if (s[i] !== s[j]) {
        dp[i][j] = false;
      } else {
        if (j - i < 3) {
          dp[i][j] = true;
        } else {
          dp[i][j] = dp[i + 1][j - 1];
        }
      }
      if (dp[i][j] && j - i + 1 > maxLen) {
        maxLen = j - i + 1;
        begin = i;
      }
    }
  }
  return s.substring(begin, begin + maxLen);
}

```
:::

::: tab cpp
```cpp
class Solution {
  public:
    string longestPalindrome(string s) {
      int n = s.size();
      if(n < 2) {
        return s;
      }
      
      int maxLen = 1;
      int begin = 0;
      vector<vector<int>> dp(n, vector<int>(n));
      
      for(int j = 1; j < len; j++) {
        for(int i = 0; i < j; i++) {
          if(s[i] != [j]) {
            dp[i][j] = false;
          } else {
            if(j - i < 3) {
              dp[i][j] = true;
            } else {
              dp[i][j] = dp[i+1][j-1];
            }
          }
          if (dp[i][j] && j - i + 1 > maxLen) {
            maxLen = j - i + 1;
            begin = i;
          }
        }
      }
      return s.substr(begin, maxLen);
    }
}
```
:::
::::


